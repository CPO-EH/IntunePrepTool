<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>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</Preview>
  <Form>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
YYGBB7GzO6GhrC2AHmhzk4/hu/8Bm3bb9Z02BAA=</Form>
  <Code><![CDATA[class config_customerinfo {
	[string]$customername
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
	
	
}
function PowershellISEOnTop {
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}	
}



$tools_winget_label_Load = {
	Set-ControlTheme $tools_winget_label -Theme Dark
	
	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv= Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($winget_exe.count -gt 1)
		{
			$winget_exe = $winget_exe[-1].Path
			& $winget_exe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
		}
		
		if (!$winget_exe)
		{
			
			[void][System.Windows.Forms.MessageBox]::Show('Winget expected in C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\ ', 'Winget missing') # Casting the method to [void] suppresses the output.  }
			
		}
		else
		{
			if (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			}
		
		}
		
		
		
	}
	$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
	if ($restrictionpolicy -ne 'Unrestricted')
	{
		
		if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		{
			$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
			if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
			{
				powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
			else
			{
				$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
				Start-Sleep 1
				powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
		}
		
		
		try
	{
		
		Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
	}
	catch
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	}
	
	$problemPSModule = $null;;
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if ($problemPSModule -eq 1)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	try
	{
		
		Get-ChildItem -Path "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -ErrorAction Stop
	}
	catch
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: Download Winget MSIX bundle', 'Winget MSIX bundle missing') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	
	
	
	refreshTenants
	#>
	$config_tabcontrol2.Dock = 'Fill'
	$config_tabcontrol2.Visible = $true
	$config_tabcontrol2.Enabled = $true
	
	
	
	
}


$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $tools_winget_label -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $tools_winget_label -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$versie = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$wingetID\$versie\source" -s "$outputDirectory\$wingetID\$versie\source\install.ps1" -o "$outputDirectory\$wingetID\$versie\output" -q
	
	Rename-Item -Path "$outputDirectory\$wingetID\$versie\output\install.intunewin" -NewName "$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Versie `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Versie `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$wingetID.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $versie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$wingetID\$versie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$wingetID\$versie\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$winget_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {

	$wgid = $winget_WingetID_textbox1.text

	
		$showurl = winget show $wgid --accept-source-agreements
		foreach ($l in $showurl)
		{
			if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
		}
		
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text

	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	
	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
		})



$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			if ($config_customerinfo.customername -eq $cis.customername)
			{
				Update-ListBox $config_listbox $cis.customername -Append
			}
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
		
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else {
		
		if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
		{
			
			New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
		{
			
			New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
		}
		$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
		$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
		$exe_output_textbox1.AppendText("`r`n")
		$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
		
		[string]$exe_org_path = $exe_openfiledialog1.FileNames
		try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false 
			Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
			$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
			$exe_panel1.Enabled = $true
			$exe_panel1.Visible = $true
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
		}
		$exe_open_sourcedir_button1.Enabled = $true
		$exe_open_sourcedir_button1.Visible = $true
		}
	}
		
		
	}
	
	$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true


	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	

}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true

	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")
	$exe_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$exe_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
}

$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_output_textbox1.AppendText("`nYou can use this for TRANSFORMS files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			 #$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:53
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
	write-host $startPMSI
	$msilog = get-content $logfileMSI
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Script started i.cmd" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
		write-host ""
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green

	}
	
	if ($msiuninstallcode -eq $null) { $excode = 1 ; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
    Else
    {
        write-host "Script started i.cmd" -ForegroundColor Green
        write-host "Possible uninstall command is:" -ForegroundColor Green
        write-host ""
        write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
        write-host ""
        Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
        write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
        $excode = 0
    }
   
	
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content $logfileMSI 
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue


    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	#$msi_installFile = $msi_installFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true
	$msi_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msi_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
	
			$config_csv_openfiledialog1.ShowDialog()
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			$upload_DisplayName_textbox1.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox1.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
		if (!(test-path "$filepath\Logo.png" -PathType Leaf))
		{
			[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
			$upload_logo_button2.Enabled = $true
			$upload_logo_button2.Visible = $true
			
		}
		
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2022 v5.8.210
	 Created on:   	26/02/2023 14:05
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
	.DESCRIPTION
		Params are used from IntunePrepTool
		Uses Powershell modules MSAL.PS from Jason Thompson and IntuneWin32App from Nickolaj Andersen
		
#>

#Requires -RunAsAdministrator
#Installatie Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
}

[string]$config_csv_path = '!!CONFIGCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		
		$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
		$tenantID = $checkCredLoad.TargetName
		$tenantID = $tenantID.Split("_")[1]
		$AppId = $checkCredLoad.UserName
		$Secret = $checkCredLoad.Password
	}
}

Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
$logoaanwezig = get-childitem "$filepath\logo.png"
if ($logoaanwezig -eq $null) { write-host "No Logo.PNG found in Output Directory" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
else
{
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
	write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam -Verbose
	if ($Win32AppEvtVorigeVersies -ne $null)
	{
		write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
		write-host $evtvversie
		$alversieAppAanwezig = $true;
		write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	}
	
	else
	{
		$alversieAppAanwezig = $false;
	}
	
	write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	 if ($logoaanwezig -eq $null) { 
        $Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -InstallExperience "system" -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose }
    else
    {
	$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience "system" -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose
    }
	Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	
	if ($SetupLikeOldVersion -eq $true)
	{
   <#
	
	$response = read-host "Press q to do nothing, Any other key for setting up dependencies. Dependency will be the same if older version. (When exists)"
	$niksdoen = $response -eq "q"
	if ($niksdoen -eq $true) { write-host "Ok.. We won't do this" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		if ($dep -notlike $null)
		{
			$dependency = Get-IntuneWin32App | Where-Object { $_.Displayname -like $dep }
			$dep2 = New-IntuneWin32AppDependency -DependencyType AutoInstall -ID $dependency.Id
			Add-IntuneWin32AppDependency -ID $Win32App.Id -Dependency $dep2 -Confirm:$false
			write-host "Dependency done"; Write-host "`r`n"; Write-host "`r`n";
		}
		else { write-host "No dependency found in older version" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	}
#>
		
		if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
		else
		{
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
				$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
				$evtvversie = $vorigeversie.DisplayVersion
				
				if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host ""; Write-host "`r`n"; Write-host "`r`n"
					$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
					$niksdoen = $response -eq "q"
					if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
					else
					{
						write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
						Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
						try
						{
							Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
						}
						catch
						{
							Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
						}
					}
				}
			}
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Write-host "We will fix superseedence for:" -ForegroundColor Green
					$vorigeversie.displayVersion
					
					$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
					$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
					if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
					Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
				}
			}
			
			
			
		}
		
		
	}
	if ($AvailableAllUsers -eq $true)
	{
		
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll -Verbose
		
	}
	
	
	if ($RequiredAllDevices -eq $true)
	{
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll -Verbose
		
		
		
		
	}
	



'@
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	
	$depWin = $upload_dep_textbox1.Text
	$tenantName = $upload_upload_listbox1.SelectedItem
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
	if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
	}
	if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
	}
	if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
	}
	
	
	
	
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$uploadIntuneFile | Out-File $filepath\uploadIntune.ps1 -Force
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE?; After uploading: Please reopen IntunePrepTool to create another package ', 'Upload to Intune', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		powershell_ise -file $filepath\uploadIntune.ps1
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$fid = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$fid\$wid\$vid\Output\logo.png" -ErrorAction Stop
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
	
	
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\output\logo.png" -ErrorAction Stop
	$msi_output_textbox1.AppendText("`r`n")
	$msi_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]
		$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]
		$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]
		$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Item,
	    [Parameter(Mandatory=$false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
	-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param(
	$InputObject, 
	[ValidateNotNull()]
	[System.Data.DataTable]$Table,
	[switch]$RetainColumns,
	[switch]$FilterCIMProperties)
	
	if($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @(,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;		
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					tenanturl	    = $cis.tenanturl;
				})
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$vid = $versie_textbox2.Text
		if ($vid -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			
			
			$wid = $winget_WingetID_textbox1.text
			
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			
			
			$WinGetID = $wid
			$regApp1 = $DisplayName
			$versie = $vid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\output"
			}
			if ($winget_install_winget_checkbox1.Checked -eq $true)
			{
				$includeWingetRequirment = $true
				Copy-Item "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" "$outputDirectory\$wingetID\$versie\source\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -Force
				
			}
			else
			{
				$includeWingetRequirment = $false
			}
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	18-5-2024 03:27
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$versie.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
if ($includeWingetRequirment -eq $true)
{
        Add-ProvisionedAppxPackage -online -PackagePath ".\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -SkipLicense -ErrorAction SilentlyContinue
		Start-Sleep 5
		$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($ResolveWingetPath)
		{
			$WingetPath = $ResolveWingetPath[-1].Path
		}
		$wingetexe = $ResolveWingetPath
		
		if (Test-path $wingetexe)
		{
			Write-host "Installation Winget success."
		}
		else
		{
			Write-Host "Installation Winget Failed."
		}
	
	
}

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>




$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

if (!$winget_exe) { Write-Error "Winget not installed" $excode = 1 }
else { $excode = 0 }

try
{
	
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine

		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget

		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		}
	}
	else
	{
		& $winget_exe uninstall --id $WinGetID -h
	}
	
	
}
catch
{	
}
if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
}
#### Place extra actions here:




<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!versie!!', $versie)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$wingetID\$versie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
		}
	}
	
}

$winget_test_install_button1_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$winget_uninstall_test_button_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$winget_show_version_button1_Click={
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click={
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);

	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
				
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
		
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
		
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			  
			
			
			
			
			
			
		}
		
	}
	
	

	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click={
	#TODO: Place custom script here
	if ( $config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click={
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged={
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click={
	#TODO: Place custom script here
	$upload_logo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $upload_logo_openfiledialog1.FileNames
	
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	
	$itwnf = $ConfigCSVImport.IntuneWinFile
	$filepath = $config_csv_path.TrimEnd("config.csv")
	Copy-Item -Path $logo_org_path -Destination "$filepath\logo.png"
}

$timer1_Tick={
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click={
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$hover_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged={
	#TODO: Place custom script here
	$hover_textbox1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile| Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $true
	$config_tabcontrol2.Visible = $true
	$config_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
	
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false

	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	
	
	
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
}





$Weblink_intunewin_tabpage6_Click={
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged={
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged={
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click={
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
			
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
			
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile )
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
	
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
	
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click={
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click={
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
			
			
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click={
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click={
	#TODO: Place custom script here

	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	05/13/2024
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the creation of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
					
					if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
					}
					
					if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
						
						if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
							$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
							
							$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
							if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
							{
								$WeeklyTaskAMPM = "AM"
							}
							else
							{
								$WeeklyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
							
						}
						if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
							
							
							$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
							if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
							{
								$DailyTaskAMPM = "AM"
							}
							else
							{
								$DailyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
							
							
							
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
							
						}
						
						
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
					}
					
				
					$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
					$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
					
				}
				
				
			}
			
			
			
			
		}
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
					if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
						
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
					}
					if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
						if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
							$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
							
							$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
							if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
							{
								$WeeklyTaskAMPM = "AM"
							}
							else
							{
								$WeeklyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
							
						}
						if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
							
							
							$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
							if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
							{
								$DailyTaskAMPM = "AM"
							}
							else
							{
								$DailyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
							
							
							
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
							
						}
						
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
					}
					
					$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
					$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
					
					
					
				}
				
			}
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click={
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>


#Nuget installation
$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
$nugetInstallPath = "$env:ProgramFiles\NuGet"
if (-not (Test-Path -Path $nugetInstallPath))
{
	New-Item -ItemType Directory -Path $nugetInstallPath -Force
}
$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
if (Test-Path -Path $nugetExePath)
{
	Write-Host "NuGet has been installed successfully at $nugetExePath"
}
else
{
	Write-Host "NuGet installation failed"
}
$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
if ($path -notlike "*$nugetInstallPath*")
{
	[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
	Write-Host "NuGet has been added to the system PATH"
}
else
{
	Write-Host "NuGet is already in the system PATH"
}
& $nugetExePath | Select-String "NuGet Version"


Get-PackageProvider -Name Nuget -Force

#Installation Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Write-Host "IntuneWin32App 1.4.4 already installed"
	}
	else
	{
		Write-Host "Required Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Authentication 2.18.0 already installed"
	}
	else
	{
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Applications 2.18.0 already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		Write-Host "CredentialManager 2.0.0 Powershell module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Identity.SignIns 2.18.0 Powershell Module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click={
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click={
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click={
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click={
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	

	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget| Select Name,ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 

}

$download_winget_listbox1_SelectedIndexChanged={
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged={
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory !!@download_winget_path@!! --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click={
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click={
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click={
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click={
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
	
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
	
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	try
	{
		$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nUbinstall.ps1 NIET created `r`n")
	}
	}
}

$exe_radiobutton3_CheckedChanged={
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged={
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click={
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken } 
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click={
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $powershell_package_name_textbox1.text
	$exeversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$exepnaam\$exeversie\output\config.csv file there", 'Upload Now?',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
	
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click={
	#TODO: Place custom script here
$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$button1_Click={
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
	
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click={
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$addTenantToolStripMenuItem_Click={
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click={
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click={
	#TODO: Place custom script here

	$tenantName = $config_tenant_name_textbox3.Text
	$appRegName = $config_tenant_appRegName_textbox3.Text
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		& "C:\Program Files\IntunePrepTool\AddAppReg.exe" -appRegName $appRegName -customername $tenantName
		
		refreshTenants
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click={
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible= $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click={
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
			$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
			$tenantID = $checkCred.TargetName
			$tenantID = $tenantID.Split("_")[1]
			$AppRegName = $checkCred.TargetName
			$AppRegName = $AppRegName.Split("_")[0]
			$config_tenant_info_tenantID_textbox3.Text = $tenantID
			$config_tenant_info_appregName_textbox4.Text = $AppRegName
			$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
			$config_tenant_info_secret_textbox3.Text = 'xxx'
			
		}
		
	}
	
	

}

$labelTenantName_Click={
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click={
	

	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click={
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
			$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			
		}
		
	}
}


$msix_create_packageDIR_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click={
	#TODO: Place custom script here
	Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click={
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
		
}

$MSIX_CreateScripts_button2_Click= {
	
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam )
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
   #$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
			
	
}

$msix_opensource_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_test_uninstall_button_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
			Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_create_uninstall_Script_button2_Click={
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName )
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click={
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	$msix_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$MSIX_UploadLogo_button_Click={
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$msixpnaam\$msixversie\output\logo.png" -ErrorAction Stop
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$powershell_open_install_ps_button2_Click={
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click={
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text

	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click={
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		
		
		$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
		
		$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text 
		$fid = $config_packagefolder; $outputDirectory = $fid
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
		Unblock-File -Path $powershell_install_org_path -Confirm:$false
		$powershellInputInstall = Get-Content -Path $powershell_install_org_path
		$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
		$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
		$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
		$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
		$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
		foreach ($line in $powershelll_installFile)
		{
			if ($line -like "#PowershellInstallStart*")
			{
				
					foreach ($inputLine in $powershellInputInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
			
			
		}
		
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\IntunePrepTool_msgfile.dll" -Confirm:$false
		
		
		
	
		
		
		[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
		Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
		$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
		$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
		$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
		foreach ($line in $powershell_uninstallFile)
		{
			if ($line -like '#PowershellUninstallStart*')
			{
				
				foreach ($inputLine in $powershellInputUNInstall)
				{
					$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
			}
			else
			{
				$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
			}
			
			
		}
		$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
		$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$Powershell_testUnInstall_button2.Enabled = $true
		$Powershell_testUnInstall_button2.Visible = $true
		$Powershell_testInstall_button2.Enabled = $true
		$Powershell_testInstall_button2.Visible = $true
		$Powershell_CreateIntuneWIn_button2.Enabled = $true
		$Powershell_CreateIntuneWIn_button2.Visible = $true
		
	}
}

$powershell_opensource_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click={
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click={
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test install?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_testUnInstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstall?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_CreateIntuneWIn_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$msipnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$powershell_output_textbox5.AppendText("un-install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$powershellpnaam"
	$regkeyApp
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Versie' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("When needed upload Logo to upload *.png file. `r`n")
	$powershell_output_textbox5.AppendText("Then use this config.csv in the upload tab to upload package to Intune. `r`n")
}

$Powershell_upload_logo_button_Click={
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$powershellpnaam\$powershellversie\output\logo.png" -ErrorAction Stop
	$powershell_output_textbox5.AppendText("`r`n")
	$powershell_output_textbox5.AppendText("Logo.PNG now available in Output Directory`r`n")
}

]]></Code>
  <TV>0</TV>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="True">757</Line>
    <Line Disabled="True">1549</Line>
    <Line Disabled="True">1551</Line>
    <Line Disabled="False">2011</Line>
    <Line Disabled="False">3598</Line>
    <Line Disabled="False">5176</Line>
    <Line Disabled="True">6170</Line>
    <Line Disabled="True">6172</Line>
    <Line Disabled="True">6278</Line>
    <Line Disabled="False">7361</Line>
    <Line Disabled="True">9859</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>0</Mode>
  <Assemblies>
    <Assembly>Renci.SshNet, Version=2016.0.0.0, Culture=neutral, PublicKeyToken=1cee9f8bde3db106|C:\Users\rink\Desktop\ex-desktop\Renci.SshNet.dll</Assembly>
  </Assemblies>
</File>