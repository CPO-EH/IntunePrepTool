<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>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
6UHrmmFyvpxZLufPlO/dLH+J62UIeFOSpIe2gyMLcfJ09QvrtdZV92+OTMarh8Zjz8HjrY/9p86+
2do7Xt7UqwHgyPjp8n03Wq8PTa/Fbw6fiN6hmdbXapCoXp8+dz2Gy8Cw98hMjMycb71HT69eL9+7
XH7Tn4kDowuxf3A6TqxsltffbP1v/IdGl8p75+VY2Hg7Zs9c2tkAcOmdiPkLb8Vi+aaFy/+91aUP
YvHy72Pp0nuxuP522XunPN+KpYvl68VbsVw9l5YvvdtqqfyQam9rvbW3dPG35ft+u/VcWtl8LybL
kDC1+tbWmdb59p/1h+rvlSTpYW25vPcdPVF+wZ04E4Mnz8XQybUYm7u41fzF8uZ9IQYmV1t7h4+v
xNDUWnkT3zpbvT48fb51rj5f7VevVz+nOj9cvr+vfK3Pj8ysx+jcRutr9T3164OlQ2OnWoNA9R66
sHplZwPA5Xej/EXejvnzN2LhPre4fjMWy7DRaU+SpEepxQs3Yn7tepxYvnTHJstv50vrb8Xs6rWY
WLrY8UzdRGnqzJVY2rgZU6evdDzTbPrs1dZ77Mrm+7F47urOBoAr70VU/yvgD1/4cTz51FPxj08/
fbtnblc/168395rrbmfr5+a629lOe/W621697rbX/lqnvQdxtv315l5zvZO95rr9bPvznfbbn9vX
7fvNvYftbP3cXHc7222vub/d892erdft+829butue+2vddrrtt7JXnPd6Wy93u75fp6t1+37zb1u
6257D/Js/Xpzr7nffL6fZ+t1p/325+3W3fY+7tn69eZec91tr15v9/yHnn7mW/FMqfra6fmZb219
bZ0tVettz7atq39W/dzcb3/+xje/Gc8++2xcuPJWnL76+7sbAFYuvxvf/va/xl//1V/G41/8Yjz+
+OPxxO3q5+prXftec93tbP3cXHc722mvXnfbq9fd9tpf67T3IM62v97ca653stdct59tf77Tfvtz
+7p9v7n3sJ2tn5vrbme77TX3t3u+27P1un2/uddt3W2v/bVOe93WO9lrrjudrdfbPd/Ps/W6fb+5
123dbe9Bnq1fb+4195vP9/Nsve603/683brb3sc9W7/e3Guuu+3V6+2e7+fZet1tv/35sc9/Pp56
8mtx9eZ7sXLlg7sfAL7z3e+VH3T7zf+JJyRJ0iPQY489Fl9/6sm48ta79z4APFEGgOqHfelLX5Ik
SY9AX/jCF+IbX7/HAeDUpVsGAEmSHsEMAJIkJexjDQCuACRJejQzAEiSlDBXAJIkJcwAIElSwlwB
SJKUMJ8ASJKUMAOAJEkJcwUgSVLCDACSJCXMFYAkSQkzAEiSlDBXAJIkJcwAIElSwlwBSJKUMAOA
JEkJcwUgSVLCfAIgSVLCDACSJCXMFYAkSQkzAEiSlDBXAJIkJcwAIElSwlwBSJKUMAOAJEkJcwUg
SVLCDACSJCXMFYAkSQnzCYAkSQkzAEiSlDBXAJIkJcwAIElSwlwBSJKUMAOAJEkJcwUgSVLCDACS
JCXMFYAkSQkzAEiSlDBXAJIkJcwnAJIkJcwAIElSwgwAkiQlzH8DIElSwnwCIElSwgwAkiQlzBWA
JEkJMwBIkpQwVwCSJCXMACBJUsJcAUiSlDCfAEiSlDADgCRJCXMFIElSwgwAkiQlzBWAJEkJMwBI
kpQwVwCSJCXMACBJUsJcAUiSlDADgCRJCXMFIElSwnwCIElSwgwAkiQlzBWAJEkJMwBIkpQwVwCS
JCXMACBJUsJcAUiSlDADgCRJCXMFIElSwgwAkiQlzBWAJEkJ8wmAJEkJMwBIkpQwVwCSJCXMACBJ
UsJcAUiSlDADgCRJCXMFIElSwgwAkiQlzBWAJEkJMwBIkpQwVwCSJCXMJwCSJCXMACBJUsJcAUiS
lDADgCRJCXMFIElSwgwAkiQlzBWAJEkJMwBIkpQwVwCSJCXMACBJUsJcAUiSlDCfAEiSlDADgCRJ
CXMFIElSwgwAkiQlzAAgSVLC/DcAkiQlzCcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsJ8AiBJ
UsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJ
CfMJgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCTMASJKU
MFcAkiQlzCcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQl
zAAgSVLCXAFIkpQwnwBIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLC
XAFIkpQwA4AkSQlzBSBJUsJ8AiBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQw
A4AkSQlzBSBJUsIMAJIkJcwVgCRJCfMJgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlz
BSBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzCcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIM
AJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwnwBIkpQwA4AkSQlzBSBJUsIMAJIkJcwV
gCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsJ8AiBJUsIMAJIkJcwVgCRJCTMA
SJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCfMJgCRJCTMASJKUMFcA
kiQlzAAgSVLCXAFIkpSwj/0JwLf/5Tvx2GOfb/0gSZL0aPS5z30uvvbVr9zbALB88Z344a5d8eTX
/j6eevIfPuzrT330uX3dvt/ce1Bn29c72WuuO52t19s938+z9bp9v7nXbd1t70GerV9v7jX3m8/3
82y9bt9v7nVbd9v7uGfr15t7zfVOzm73fD/P1utu+82zO93rdLZ+vbnXXN/t2e326vV2z5/k2Xrd
6dx26zvtNb/Wz9ud7bTXXH/SZzs91+tuZ+t1/dxc38vZ+rVOe/d6tv315l5zfS9nv/qVv4sfPPf9
uHq3A8DmuxELF27G2qXrZXq41Zogtr52em5ft+839x7U2fb1Tvaa605n6/V2z/fzbL1u32/udVt3
23uQZ+vXm3vN/ebz/Txbr9v3m3vd1t32Pu7Z+vXmXnO9k7PbPd/Ps/W6237z7E73Op2tX2/uNdd3
e3a7vXq93fMnebZedzq33fpOe82v9fN2ZzvtNdef9NlOz/W629l6XT831/dytn6t0969nm1/vbnX
XN/L2fL1xq1Yv/ZunLr8/s4GgF0vvNhz7YOIlc334/TVD1qTgyRJesTa/F15838vzr75P3Fq/cad
B4DvfPf7+y/ffD+W1q5JkqRHvJWNm7FweuPOAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwKPvUp/4PX+MLY6j4rE8AAAAASUVORK5CYII=</Preview>
  <Form>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
WnhPsaAw95RcSZD8M/jtfy5A5fTs2wQA</Form>
  <Code><![CDATA[class config_customerinfo {
	[string]$customername
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
	
	
}
function PowershellISEOnTop
{
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}
}



$tools_winget_label_Load = {
	Set-ControlTheme $tools_winget_label -Theme Dark
	
	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($winget_exe.count -gt 1)
		{
			$winget_exe = $winget_exe[-1].Path
			& $winget_exe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
		}
		
		if (!$winget_exe)
		{
			
			[void][System.Windows.Forms.MessageBox]::Show('Winget expected in C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\ ', 'Winget missing') # Casting the method to [void] suppresses the output.  }
			
		}
		else
		{
			if (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			}
			
		}
		
		
		
	}
	$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
	if ($restrictionpolicy -ne 'Unrestricted')
	{
		
		if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		{
			$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
			if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
			{
				powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
			else
			{
				$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
				Start-Sleep 1
				powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
		}
		
		
		try
		{
			
			Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
		}
		catch
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		}
	}
	
	$problemPSModule = $null;;
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if ($problemPSModule -eq 1)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	try
	{
		
		Get-ChildItem -Path "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -ErrorAction Stop
	}
	catch
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: Download Winget MSIX bundle', 'Winget MSIX bundle missing') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	
	
	
	refreshTenants
	#>
	$config_tabpage.Dock = 'Fill'
	$config_tabpage.Visible = $true
	$config_tabpage.Enabled = $true
	
	
	
	
}


$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $tools_winget_label -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $tools_winget_label -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$versie = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$wingetID\$versie\source" -s "$outputDirectory\$wingetID\$versie\source\install.ps1" -o "$outputDirectory\$wingetID\$versie\output" -q
	
	Rename-Item -Path "$outputDirectory\$wingetID\$versie\output\install.intunewin" -NewName "$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Versie `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Versie `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$wingetID.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $versie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$wingetID\$versie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$wingetID\$versie\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$winget_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {
	
	$wgid = $winget_WingetID_textbox1.text
	
	
	$showurl = winget show $wgid --accept-source-agreements
	foreach ($l in $showurl)
	{
		if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
	}
	
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	
	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
		})
	
	
	$existing_customerinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$filtered_customerinfo = $existing_customerinfo | Where-Object { $_.customername -ne $config_customerinfo.customername }
	$filtered_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Force
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		$config_listbox.ClearSelected()
		$config_listbox.Items.Clear()
		$config_listbox.Refresh()
		foreach ($cis in $config_import_csv)
		{
		
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$exepnaam = $exepnaam -replace (" ", "")
	$exe_packagenaam_textbox1.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
			$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
			
			[string]$exe_org_path = $exe_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false
				Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
				$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
				$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
				$exe_panel1.Enabled = $true
				$exe_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
			}
			$exe_open_sourcedir_button1.Enabled = $true
			$exe_open_sourcedir_button1.Visible = $true
		}
	}
	
	
}

$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true
	
	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")
	$exe_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$exe_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msipnaam = $msipnaam -replace (" ", "")
	$msi_packagenaam_textbox1.text = $msipnaam
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			#$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:53
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
	write-host $startPMSI
	$msilog = get-content $logfileMSI
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Script started i.cmd" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
		write-host ""
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green

	}
	
	if ($msiuninstallcode -eq $null) { $excode = 1 ; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
    Else
    {
        write-host "Script started i.cmd" -ForegroundColor Green
        write-host "Possible uninstall command is:" -ForegroundColor Green
        write-host ""
        write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
        write-host ""
        Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
        write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
        $excode = 0
    }
   
	
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content $logfileMSI 
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue


    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	#$msi_installFile = $msi_installFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true
	$msi_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msi_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
		
		$config_csv_openfiledialog1.ShowDialog()
		[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
		$ConfigCSVImport = Import-Csv $config_csv_path
		#Write-Host $ConfigCSVImport
		$itwnf = $ConfigCSVImport.IntuneWinFile
		$filepath = $config_csv_path.TrimEnd("config.csv")
		$itwnffilepath = $filepath + $itwnf
		$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
		$upload_DisplayName_textbox1.Text = $ConfigCSVImport.DisplayName
		$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
		$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
		$upload_reglocation_textbox1.Text = $ConfigCSVImport.reglocation
		$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
		$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
		$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
		if (!(test-path "$filepath\Logo.png" -PathType Leaf))
		{
			[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
			$upload_logo_button2.Enabled = $true
			$upload_logo_button2.Visible = $true
			
		}
		
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2022 v5.8.210
	 Created on:   	26/02/2023 14:05
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
	.DESCRIPTION
		Params are used from IntunePrepTool
		Uses Powershell modules MSAL.PS from Jason Thompson and IntuneWin32App from Nickolaj Andersen
		
#>

#Requires -RunAsAdministrator
#Installatie Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
}

[string]$config_csv_path = '!!CONFIGCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain') {
		$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
		$tenantID = $checkCredLoad.TargetName
		$tenantID = $tenantID.Split("_")[1]
		$AppId = $checkCredLoad.UserName
		$Secret = $checkCredLoad.Password
		}
		else {
		$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
		$tenantID = $cust.tenantID
		$AppId = $cust.appId
		$Secret = $cust.clientsecret

		}
	}
}

Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
$logoaanwezig = get-childitem "$filepath\logo.png"
if ($logoaanwezig -eq $null) { write-host "No Logo.PNG found in Output Directory" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
else
{
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
	write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam -Verbose
	if ($Win32AppEvtVorigeVersies -ne $null)
	{
		write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
		write-host $evtvversie
		$alversieAppAanwezig = $true;
		write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	}
	
	else
	{
		$alversieAppAanwezig = $false;
	}
	
	write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	 if ($logoaanwezig -eq $null) { 
        $Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -InstallExperience "system" -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose }
    else
    {
	$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience "system" -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose
    }
	Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	
	if ($SetupLikeOldVersion -eq $true)
	{
   <#
	
	$response = read-host "Press q to do nothing, Any other key for setting up dependencies. Dependency will be the same if older version. (When exists)"
	$niksdoen = $response -eq "q"
	if ($niksdoen -eq $true) { write-host "Ok.. We won't do this" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		if ($dep -notlike $null)
		{
			$dependency = Get-IntuneWin32App | Where-Object { $_.Displayname -like $dep }
			$dep2 = New-IntuneWin32AppDependency -DependencyType AutoInstall -ID $dependency.Id
			Add-IntuneWin32AppDependency -ID $Win32App.Id -Dependency $dep2 -Confirm:$false
			write-host "Dependency done"; Write-host "`r`n"; Write-host "`r`n";
		}
		else { write-host "No dependency found in older version" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	}
#>
		
		if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
		else
		{
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
				$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
				$evtvversie = $vorigeversie.DisplayVersion
				
				if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host ""; Write-host "`r`n"; Write-host "`r`n"
					$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
					$niksdoen = $response -eq "q"
					if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
					else
					{
						write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
						Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
						try
						{
							Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
						}
						catch
						{
							Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
						}
					}
				}
			}
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Write-host "We will fix superseedence for:" -ForegroundColor Green
					$vorigeversie.displayVersion
					
					$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
					$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
					if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
					Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
				}
			}
			
			
			
		}
		
		
	}
	if ($AvailableAllUsers -eq $true)
	{
		
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll -Verbose
		
	}
	
	
	if ($RequiredAllDevices -eq $true)
	{
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll -Verbose
		
		
		
		
	}
	



'@
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	
	$depWin = $upload_dep_textbox1.Text
	$tenantName = $upload_upload_listbox1.SelectedItem
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
	if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
	}
	if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
	}
	if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
	}
	
	
	
	
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$uploadIntuneFile | Out-File $filepath\uploadIntune.ps1 -Force
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE?; After uploading: Please reopen IntunePrepTool to create another package ', 'Upload to Intune', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		powershell_ise -file $filepath\uploadIntune.ps1
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$fid = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$fid\$wid\$vid\Output\logo.png" -ErrorAction Stop
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
	
	
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msi_output_textbox1.AppendText("`r`n")
	$msi_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
		[ValidateNotNull()]
		[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
		[ValidateNotNull()]
		[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		$Item,
		[Parameter(Mandatory = $false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView])
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param (
		$InputObject,
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterCIMProperties)
	
	if ($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @( ,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					downloadpath    = $cis.downloadpath
				})
		}
		
		
	}
	
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkName = $weblinkName -replace (" ", "")
	$weblink_packagename.Text = $weblinkName
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click = {
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$vid = $versie_textbox2.Text
		if ($vid -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			
			
			$wid = $winget_WingetID_textbox1.text
			
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			
			
			$WinGetID = $wid
			$regApp1 = $DisplayName
			$versie = $vid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\output"
			}
			if ($winget_install_winget_checkbox1.Checked -eq $true)
			{
				$includeWingetRequirment = $true
				Copy-Item "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" "$outputDirectory\$wingetID\$versie\source\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -Force
				
			}
			else
			{
				$includeWingetRequirment = $false
			}
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	18-5-2024 03:27
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$versie.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
if ($includeWingetRequirment -eq $true)
{
        Add-ProvisionedAppxPackage -online -PackagePath ".\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -SkipLicense -ErrorAction SilentlyContinue
		Start-Sleep 5
		$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($ResolveWingetPath)
		{
			$WingetPath = $ResolveWingetPath[-1].Path
		}
		$wingetexe = $ResolveWingetPath
		
		if (Test-path $wingetexe)
		{
			Write-host "Installation Winget success."
		}
		else
		{
			Write-Host "Installation Winget Failed."
		}
	
	
}

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>




$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

if (!$winget_exe) { Write-Error "Winget not installed" $excode = 1 }
else { $excode = 0 }

try
{
	
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine

		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget

		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		}
	}
	else
	{
		& $winget_exe uninstall --id $WinGetID -h
	}
	
	
}
catch
{	
}
if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
}
#### Place extra actions here:




<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!versie!!', $versie)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$wingetID\$versie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
		}
	}
	
}

$winget_test_install_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$winget_uninstall_test_button_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$winget_show_version_button1_Click = {
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click = {
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			
			
			
			
			
			
			
		}
		
	}
	
	
	
	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click = {
	#TODO: Place custom script here
	if ($config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click = {
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click = {
	#TODO: Place custom script here
	$upload_logo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $upload_logo_openfiledialog1.FileNames
	
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	
	$itwnf = $ConfigCSVImport.IntuneWinFile
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$filepath\logo.png"
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
}

$timer1_Tick = {
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click = {
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$hover_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged = {
	#TODO: Place custom script here
	$hover_textbox1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
	
	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}




$Weblink_intunewin_tabpage6_Click = {
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click = {
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
				
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile)
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
		
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
		
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click = {
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_name = $package_scheduledTask_name -replace (" ", "")
				$powershell_package_name_textbox1.Text = $package_scheduledTask_name
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
				
				
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click = {
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	6-10-2024 17:54
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -executionpolicy bypass -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Settings $settings -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				Write-Host "Eerste stap"
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			Write-Host "Check"
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
			
			if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
			}
			
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			Write-Host "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
			
		}
		
		
		
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
			}
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click = {
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>


#Nuget installation
$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
$nugetInstallPath = "$env:ProgramFiles\NuGet"
if (-not (Test-Path -Path $nugetInstallPath))
{
	New-Item -ItemType Directory -Path $nugetInstallPath -Force
}
$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
if (Test-Path -Path $nugetExePath)
{
	Write-Host "NuGet has been installed successfully at $nugetExePath"
}
else
{
	Write-Host "NuGet installation failed"
}
$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
if ($path -notlike "*$nugetInstallPath*")
{
	[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
	Write-Host "NuGet has been added to the system PATH"
}
else
{
	Write-Host "NuGet is already in the system PATH"
}
& $nugetExePath | Select-String "NuGet Version"


Get-PackageProvider -Name Nuget -Force

#Installation Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Write-Host "IntuneWin32App 1.4.4 already installed"
	}
	else
	{
		Write-Host "Required Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Authentication 2.18.0 already installed"
	}
	else
	{
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Applications 2.18.0 already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		Write-Host "CredentialManager 2.0.0 Powershell module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Identity.SignIns 2.18.0 Powershell Module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click = {
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click = {
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click = {
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click = {
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$download_winget_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click = {
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click = {
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click = {
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click = {
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click = {
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
		
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		try
		{
			$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUbinstall.ps1 NIET created `r`n")
		}
	}
}

$exe_radiobutton3_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $powershell_package_name_textbox1.text
	$exeversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if ([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$exepnaam\$exeversie\output\config.csv file there", 'Upload Now?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
		
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$button1_Click = {
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
		
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click = {
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$addTenantToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked = [System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click = {
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click = {
	#TODO: Place custom script here
	
	$tenantName = $config_tenant_name_textbox3.Text
	$appRegName = $config_tenant_appRegName_textbox3.Text
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant with Global Admin rights. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		if ($config_add_Tenant_radiobutton1.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppReg.exe" -appRegName $appRegName -customername $tenantName
		}
		if ($config_add_Tenant_radiobutton2.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe" -appRegName $appRegName -customername $tenantName
		}
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click = {
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click = {
	
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click = {
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click = {
	#TODO: Place custom script here
	Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click = {
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
	
}

$MSIX_CreateScripts_button2_Click = {
	
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	#$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
	
	
}

$msix_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_test_uninstall_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_create_uninstall_Script_button2_Click = {
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName)
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click = {
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	$msix_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$MSIX_UploadLogo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$msixpnaam\$msixversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$powershell_open_install_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellpnaam = $powershellpnaam -replace (" ", "")
	$powershell_packagename_textbox.text = $powershellpnaam
	$powershellversie = $powershell_packageversion_textbox.Text
	
	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click = {
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		
		
		$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
		
		$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		$fid = $config_packagefolder; $outputDirectory = $fid
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
		Unblock-File -Path $powershell_install_org_path -Confirm:$false
		$powershellInputInstall = Get-Content -Path $powershell_install_org_path
		#Write-Host $powershellInputInstall
		$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
		$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
		$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
		$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
		$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
		foreach ($line in $powershelll_installFile)
		{
			if ($line -like "#PowershellInstallStart*")
			{
				
				foreach ($inputLine in $powershellInputInstall)
				{
					
					$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
			}
			else
			{
				$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
			}
			
			
		}
		
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		
		
		
		
		
		
		[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
		Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
		$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
		$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
		$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
		foreach ($line in $powershell_uninstallFile)
		{
			if ($line -like '#PowershellUninstallStart*')
			{
				
				foreach ($inputLine in $powershellInputUNInstall)
				{
					$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
			}
			else
			{
				$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
			}
			
			
		}
		$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
		$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$Powershell_testUnInstall_button2.Enabled = $true
		$Powershell_testUnInstall_button2.Visible = $true
		$Powershell_testInstall_button2.Enabled = $true
		$Powershell_testInstall_button2.Visible = $true
		$Powershell_CreateIntuneWIn_button2.Enabled = $true
		$Powershell_CreateIntuneWIn_button2.Visible = $true
		
	}
}

$powershell_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test install?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_testUnInstall_button2_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstall?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_CreateIntuneWIn_button2_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$msipnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$powershell_output_textbox5.AppendText("un-install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$powershellpnaam"
	$regkeyApp
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Versie' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("When needed upload Logo to upload *.png file. `r`n")
	$powershell_output_textbox5.AppendText("Then use this config.csv in the upload tab to upload package to Intune. `r`n")
}

$Powershell_upload_logo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$powershellpnaam\$powershellversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
	$powershell_output_textbox5.AppendText("`r`n")
	$powershell_output_textbox5.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$updatepackage_msi_open_config_button1_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click = {
	#TODO: Place custom script here
	
}

$labelAppName_Click = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged = {
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click = {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$updatepackage_msi_appname_new_textbox3.text = $powershellpnaam
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}



$exe_open_Azure_OpenAI_Example_button1_Click = {
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click = {
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
		
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key		       = $config_openAI_textbox6.Text
			endpointURL    = $config_openAI_textbox7.Text
			deploymentName = $config_openAI_textbox8.Text
			
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}


$config_openAI_help_Click = {
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"
}




$config_openAI_textbox8_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox6_TextChanged = {
	#TODO: Place custom script here
	
}
]]></Code>
  <TV>0</TV>
  <Mode>0</Mode>
  <Assemblies>
    <Assembly>Renci.SshNet, Version=2016.0.0.0, Culture=neutral, PublicKeyToken=1cee9f8bde3db106|C:\Users\rink\Desktop\ex-desktop\Renci.SshNet.dll</Assembly>
  </Assemblies>
</File>