<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAAAXNSR0IArs4c6QAAAARnQU1BAACx
jwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABiuSURBVHhe7d1ZcxRpvtjh85l8N5/CN7bDESfC
F77z8ZkeX/rCdoR9bJ/pM3aMZ2iY3qBhEAy9TtPsaEFC+1YS2oUWhJCQEGhhhxb035EpJCRVSSUq
xZzJ1vNE/AJRb2WWVK3oesnKN+tv/gYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyOI//O3f/ruq41VfVn1y9KQk
Scppnx2rqjp64nTVL37xi6rtL/ZF/tW//jffdwxNx8D0o7hxa0mSJO1XU3toL/fby33eNDT7NM7V
NMf21/siJ09/UzU0+yTqeyfjuiRJylxD8ueNW3GtML5z3ePpfRrL3a8wnt4n2W+yzfax9eoLE+n+
rvdOxY2JhfITgORQwfDs42jqn4rm/ttxvX8urg/MR9PwUjQPzkVz31Q0D0xH85vxtTZ//fbvrYMz
0TIwHU3JNutjb75uHZqJlsE7b8fSP6fTfW+5vyRJOa9lcDquNA/GD3U9cb6+t2TnrvXEhev9cbGx
P/36fP2NuNDQF2freuOHa71x4Xrfxv2S+6R/T25vuJFul3S+4c3t9b3pY11tGUpfbws37+5tAjA6
9zRa0hfv2zHR+12MtX0eXef/S7Q2fBOtw/eisXci2kfmon14NloHpqNteDbahmajfeRutA+v1TEy
G7WtN9LZydp9766Nj8xF2+B01DQXorZjJDpG59Ptk9tb+m9FY+9k+s22Dt6RJOlnUfI6l7xA1xfG
o6FnMpr6b0dj33RaU9/taOiZiKa+W+mL/g91vem/8OsLk/HnS01xua41LlQ3xQ91Xel9k3/5n60t
pJOD5B/MtZ034+tz1+Lrc/Xx9dnaOF9fiMa+qbjWNRYXr/dHx+hc9I7NlZ8AHDtxumri/ovouHk/
ugf6Y/7yv40HhUPRcvhfRGvNieiaXInalp6obeuLutbeuFjXkr5ot/RNxrXktvbBaOweSV/gL9Y0
xsX6jrjWORzX2vujtq0//bOxdzxqmzujprU/rnUMpH+v7xiM2taeqG0fju7xe9E5eleSpJ9F3WPz
caVlKBp7bkVz/504V9cVF2ra4nxNa5y/Vkhva+mfjstNg+mLdsvAnajpGI/LV6/H199eiMuXa+Nc
dWu0DMymR8uTF/8rzUPpUfPkEP/pb67EYP9AfH/uapy/3hfNA3fSScXVluEoTCxE/+Qe3gI4dvJP
VbeXX0Vh6mn0d56NqYv/PkZr/zGuffovo6PQEb1Ty1HX0hlXrnfE1Ya2uNzQETXN3XG5viUu1rVF
TVNX/HCxJs7XNsWlurZounEzapu740J1Q5yvbU4nBbVtA9HUm9xeiCsN7XGloTWuNHSk+2gojMeN
qcXomViQJOln0Y1bD6KmbSSa+6ajdXguqr65HJcuVceli9Vx+tur0TY8nx5Jv9o6nE4Ckq+b+mfi
1NcX4+Spb+Jk1dfx3aXm6Bi9l769fqlxIN1f5+h8+mL/+cnv4szX5+OzL87Exes3ouvmvXSiUNM+
Gv3TyzF0e7H8BOD4yT9VzTyK6Jt+FAOjQ9HfWx+9vU1RuNEZNyYXov/2UhRuzkZhbC6tc3g6Ooam
oqVvIrpvzkXP+Hx0DU9H++BUFMYXYmB6KQpj8+k2bX03o7qxK7rGF6J34l70jM9FW/9kFMbno71/
MrpGZ6Nn/F76GH1Ti5Ik/SwavLMSte03o7X/TnSMzEVj71T6Qp/UdON2dAzPRefIXFS3jqT/su8Y
upve1lCYTF/ok1r6ptPb2gdn43LTUNS2jUbX6Hx0DN+Nhu6JuJbUORZtgzPpvlr7p6OucyyG7z6O
0ZnlvUwAvqyaexIxPPsoJhd/iomliMmk5YjJBz9G8vZA8ud6txZX06aWXsWtTbdt/P3+yze3JX9/
GWPzz9Px9e2T+6Xj6f3Xbk8eY+L+S0mSfhYlr4eD0w/TF/bO4fnoHr0XhbH7acnXyW0dQ3PRN7kU
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</Preview>
  <Form>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
xYA4ySBIcr919kJjGrYtj9ieidhymnWraIF/xOIwzrw2bs64rE++7nz0YDceNdgYcAEwlgkphn1E
rH8j7i8QoHNI8INBzpw2NroYtxsoMHRheXwGulxmSY4Nv+LTVsR/R0awMgaCqefYP6kUjknfOf6w
ZwY2FNmEh9A05CTlDJrKT5/b9KteLb0dNgge3cVOZME1pyyO4dsC8y4z8TfCGXgqGBzC+KEry6fe
HBJTI5di2YH1qHcZH/6dsCao2tb+4LcOVN1NgWI6+Jr+xbw445Sv/xV7+UZrGX+ojGXQU6He7k5K
XdCromD04RgXcs/6H/mVMFPi4IN8ZZjvdEu5XLXSLMQ+J/lH/bOCdN8qlbvXV/3SSJPiWrNC88+T
j1rnbiZNEw8vfYlOvDdTObH79tKbc7L6MO31Cm2pJ09fWs9tSaPbX+JLudpuFErJp9Jcuq0s766v
ErmXDNuq3r5VaHWcfn95eyjV7++KhWpH4MrVhZR7rn181Lts7UGaDgq1YouXxRYjM81pLbZazUYs
01SfMyPhjRl+Xl+p5V8Tqd594HvPSvJu0nmY8p2b3PvX18vkVs4Xp/IoF4u1b7JfdDFZ/nW7rDZW
tWznK798i99+PtdfHsrL1XMjGctrNfr6qsi9rArvq9vHVbHBZErJ0bj+Nlvm38Tkw+fbXX3+lszP
i881On83yT3V0qP+gGncL59is1gh0W0ruXou9vj0UlyJz4X89dXgkZWWL3z7gW91Kq3HZrOjZpji
Uky/57srkS90+Wdu1Zuz1XupIszUQYnJfjwupsPmZ5uvPSaKH4L6lpvIbKwoatdXHwl1ymUX1Un7
/b2WVePJWKkk1ar8WKjU+O5EXU4e2Mfc9KV7O37is4PMo5bplhbvtVVvoubiCrO6ux13yo3Yw22+
cH1VnRXKA2FVLXA8nWbTlXy7Usj2HisD+u5lUh49yU+P2cTkhq/f3wj0LJvPaZle5r7GsM/tal3I
ZsRKNtVSKv1Ovf58fSXdNNPjbKYqjrrMV1MqjW/Z56ePyWLViX2u+nl28FiPDbhui4n/KtYfk/2i
OBo83WQmuWnv66YkcaNldZBjWJob9/U1XbU69dT0+eGjyNeUX6k0Xx1PHuqD2Lz8NX6rMEs22e9M
Zo1sv9YYifp32ZLMfz71+nxR4B75VH28KNRH/dxA+GgI11fjXPqLL6ST05eytGrerMShcH9fTkrv
WqE8j91OVsuXZb2VKCvsKvclVN4yn3f5D/azmc8/P7fjj4VYKj8rT7orJXZ7e33Vmt9Pqx/JCpv4
yj5UlX6u+jxf3N4kGTHWjyVlviNmxi1B6L40nirzzkRQxOE8N1aVm/LkLTcbVYsPL9liSZnd55+Z
66u4LErv+Scm/vn2/DnNJWKF9HA0v+/w4/JXrP9MMzXmVonlM6PHxVOzX+o+cfHb/k32JnFDP3zG
WzfjgTRLPsjp+W2+fX11wzLa/ep9Uc4WH3PxyY0mqeJDc35fjKeH7x8NpSUN7nudj1xvOMszg0ox
nn3L9XqK/vNAfSz0lrP0W1ZoJ8ddJVu8vpo1aJb7SpXfE63RY2P0QI/ExUdzdZdJ9VPSeHI3Wvay
vUotOxfu2Uo9XkjLNzX5SUuWy0xRvhnzhV/1Nz7XaYz7peT11WO8vszmYgXmLXPXz2ZySq30WL0r
32jNj3S8/jxoPagfuWrtI3fffCqyjVk5PshP2GehyirDW+1zJWSL8cdarsm99RrXV72bX/fj5mOh
+1HOFFrl5aRduy0vxtxtbbCiW2Ip05X4X79WhexnlxOfi43E41Oh26xktKbG5DutTLqdZfPcvDYY
ier1VbbxJXBPpWSto6QnuXkmM+qxX61l61eRo7vjEjtdJnur+FBZcTSbf0plukl19dIaMav6Q1X6
bC+4zu1bJt2cMen0zfUV0Aq9RiHVe+dL6nsmVpMnL900r+iadnI/mPDd5LD58fVLWnDlj6/Fr3z7
s8/oc4xn841bcTF60z7lmprrFfOfA11b0skWJyyFBT2K/6KlGDdq3D9mnpbz9+EkmypMCs23j3Qx
85bOcKnaaFnKjub0Z3fJxztLQ6/ft7psSXm/H4/H//zz75hlHg7sC6bpyUniWPcMa+JwKAlVYUTo
WCbSf1JZ/FiQszuAH7JlQNIYTvx4273EP2fp6LPeCtj+aMpL3UmaCDoFd+1SOE9dbFfiQvzNyNuM
vM3I24y8zcjbjLzNyNsMt7fJ0JgHM/vepldfE7i7pDk9pL7m3cV5mpfmZ5pxWjPdQfWW1xMUh3Hn
FAzePcbt4GCPL77m5GBtC3dPD0yha/uWjwM/BNhjIrbMBLysgpEbonNmpsoLhRdwZCgYl+aOXMMh
mQBiB+neCUmxOWQj5jU8ms0QXpR3Pi23F7aGPtW/qbYxWaooKjoYZeUL+SGElRwID76dssoP+X38
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</Form>
  <Code><![CDATA[


class config_customerinfo {
	[string]$customername
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	[string]$buildingblockspath
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			#$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function refreshTenantsUpload
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$upload_treeview2.BeginUpdate()
		$upload_treeview2.Refresh()
		$upload_treeview2.Nodes.Clear()
		$upload_treeview2.CheckBoxes = $true
		$Root = $upload_treeview2.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			#$upload_treeview2.Nodes.Add($tenantCSV.customername)
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			
			
		}
		$Root.Expand()
		$upload_treeview2.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function PowershellISEOnTop
{
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}
}



$IntunePrepTool_Load = {
	Set-ControlTheme $IntunePrepTool -Theme Dark
	#Set-ControlTheme $config_tabpage -Theme Dark
	$scaledHeight = ConvertTo-ScaledPixel -Form $IntunePrepTool -Height 720
	$scaledWidth = ConvertTo-ScaledPixel -Form $IntunePrepTool -Width 1725
	

	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			Update-ListBox $update_exe_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
		if ($restrictionpolicy -ne 'Unrestricted')
		{
			
			if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
				if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
				{
					powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
				else
				{
					$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
					Start-Sleep 1
					powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
			}
		}
		else
		{
			if (Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf)
			{
				Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
			}
			$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
			if ($ResolveWingetPath)
			{
				$WingetPath = $ResolveWingetPath[-1].Path
			}
			$wingetexe = $ResolveWingetPath
			
			if (Test-path $wingetexe)
			{
				$wingetOption = 1
				$version = & $wingetexe --version
			}
			else
			{
				$wingetOption = 2
				$version = winget --version
			}
			if (($version -notlike 'v1.9*') -and ($version -notlike 'v1.10*'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use button to Install / Update Winget', 'Winget missing or wrong version')
				
			}
			else
			{
			<#
			if ($wingetOption -like 1)
			{
				& $wingetexe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
				$IntunePrepToolversion = & $wingetexe list --id rink-turksma.IntunePrepTool
			}
			else
			{
				winget search rink-turksma.IntunePrepTool --accept-source-agreements
				$IntunePrepToolversion = winget list --id rink-turksma.IntunePrepTool
			}
			Write-Host $IntunePrepToolversion
			if ($IntunePrepToolversion | Select-String '\bVersion\s+Available\b')
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			} #>
			}
			
			
			
			try
			{
				
				Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
			}
			catch
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			}
			if (Test-Path 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -PathType Leaf)
			{
				$reqPSModules = Get-Content 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt'
				if ($reqPSModules -like 'false')
				{
					Remove-Item 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Confirm:$false -Force
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
				}
			}
			else
			{
				$problemPSModule = $null;;
				if (Get-Module -ListAvailable -Name IntuneWin32App)
				{
					$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
					
					if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
					{
						
					}
					else
					{
						$problemPSModule = 1
					}
				}
				else
				{
					$problemPSModule = 1
					
				}
				if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
				{
					$moduleVersion = $null;
					$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
					
					if ($moduleVersion.Count -ge 1)
					{
						
					}
					else
					{
						$problemPSModule = 1
					}
				}
				else
				{
					$problemPSModule = 1
					
				}
				if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
				{
					$moduleVersion = $null;
					$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
					
					if ($moduleVersion.Count -ge 1)
					{
						
					}
					else
					{
						$problemPSModule = 1
					}
				}
				else
				{
					$problemPSModule = 1
					
				}
				if (Get-Module -ListAvailable -Name CredentialManager)
				{
					$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
					
					if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
					{
						
					}
					else
					{
						$problemPSModule = 1
					}
				}
				else
				{
					$problemPSModule = 1
					
				}
				if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
				{
					$moduleVersion = $null
					$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
					
					if ($moduleVersion.Count -ge 1)
					{
						
					}
					else
					{
						$problemPSModule = 1
					}
				}
				else
				{
					$problemPSModule = 1
					
				}
				if ($problemPSModule -eq 1)
				{
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					"false" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
				}
				else
				{
					"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
				}
			}
			
			
			if (!(test-path -path 'C:\ProgramData\chocolatey'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: "Install Chocolatey"', 'Chocolatey missing') # Casting the method to [void] suppresses the output. 
				
			}
			
			
			refreshTenants
			refreshTenantsUpload
			
			$config_tabpage.Dock = 'Fill'
			$config_tabpage.Visible = $true
			$config_tabpage.Enabled = $true
			
			
			
			
			$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
			$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
			$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
			
		}
	}
}





$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $IntunePrepTool -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $IntunePrepTool -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$version = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$wingetID\$version\source" -s "$outputDirectory\$wingetID\$version\source\install.ps1" -o "$outputDirectory\$wingetID\$version\output" -q
	
	Rename-Item -Path "$outputDirectory\$wingetID\$version\output\install.intunewin" -NewName "$outputDirectory\$wingetID\$version\output\$wingetID.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\output\$wingetID.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Version `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Version `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$wingetID.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $version;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$wingetID\$version\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$wingetID\$version\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$winget_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
	$buildingBlokcsCSV = $winget_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$wingetID\$version\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$DisplayName\BuildingBlocks.csv" -force -NoTypeInformation
		$winget_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$winget_output_textbox3.AppendText("$config_buildingblockspath\$DisplayName\BuildingBlocks.csv `r`n")
		$winget_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
	
	
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {
	
	$wgid = $winget_WingetID_textbox1.text
	
	
	$showurl = winget show $wgid --accept-source-agreements
	foreach ($l in $showurl)
	{
		if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
	}
	
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	[string]$c_buildingblocksfolder  = $config_buildingblocks_textbox3.text
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	
	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
			buildingblockspath = $c_buildingblocksfolder;
		})
	
	
	$existing_customerinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$filtered_customerinfo = $existing_customerinfo | Where-Object { $_.customername -ne $config_customerinfo.customername }
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Force
	$filtered_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		$config_listbox.ClearSelected()
		$config_listbox.Items.Clear()
		$config_listbox.Refresh()
		foreach ($cis in $config_import_csv)
		{
		
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
				Update-ListBox $update_exe_listbox1 $cis.customername -Append
			
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	$exe_maakPackageDir_button1.Enabled = $true
	$exe_open_Azure_OpenAI_Example_button1.Enabled = $true
	$exe_open_withqquestion_button1.Enabled = $true
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$exepnaam = $exepnaam -replace (" ", "")
	$exe_packagenaam_textbox1.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
			$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
			
			[string]$exe_org_path = $exe_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false
				Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
				$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
				$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
				$exe_panel1.Enabled = $true
				$exe_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
			}
			$exe_open_sourcedir_button1.Enabled = $true
			$exe_open_sourcedir_button1.Visible = $true
			$exe_maakScripting_button1.Enabled = $true
		}
	}
	
	
}

$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("After successful test in PowerShell ISE. Please click the 'Test Done' button.", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		$backupFolder = "$env:LOCALAPPDATA\temp"
		$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges64_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script
		}
		
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges32_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script
		}
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$exe_test_done_button1CreateInstallScript.Enabled = $true
		$exe_gotobuildingblocksButton.Enabled = $true
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$exe_addBuildingBlocksCSVButton.Enabled = $true
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true
	
	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")
	$exe_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$exe_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $exe_buildingblockscsv_textbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$exepnaam\$exeversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$exepnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$exe_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$exe_output_textbox1.AppendText("$config_buildingblockspath\$exepnaam\BuildingBlocks.csv `r`n")
		$exe_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
	
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	#$msi_reg_hklm_label5.Visible = $false
	#$msi_reg_hklm_label5.Enabled = $false
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msipnaam = $msipnaam -replace (" ", "")
	$msi_packagenaam_textbox1.text = $msipnaam
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			#$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
			$msi_open_Orca_button1.Enabled = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:53
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
	write-host $startPMSI
	$msilog = get-content $logfileMSI
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Script started i.cmd" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
		write-host ""
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green

	}
	
	if ($msiuninstallcode -eq $null) { $excode = 1 ; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
    Else
    {
        write-host "Script started i.cmd" -ForegroundColor Green
        write-host "Possible uninstall command is:" -ForegroundColor Green
        write-host ""
        write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
        write-host ""
        Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
        write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
        $excode = 0
    }
   
	
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content $logfileMSI 
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue


    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

if (Test-Path 'hklm.reg') {
    Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hklm.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	#$msi_installFile = $msi_installFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("When you want to add Building Blocks to this package, test installation first, then use the '(Optional) Go to Building Blocks' button", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_buttonOptionalGoToBuilding.Enabled = $true
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true
	$msi_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msi_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $MSI_buildigblocks_Package_InProgresstextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$msipnaam\$msiversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msipnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msi_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msi_output_textbox1.AppendText("$config_buildingblockspath\$msipnaam\BuildingBlocks.csv `r`n")
		$msi_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI_uninstall"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile.Enabled = $true;
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
		
		$config_csv_openfiledialog1.ShowDialog() | Out-Null
		if ($config_csv_openfiledialog1.FileNames -notcontains 'config_csv_openfiledialog1')
		{
			$upload2_IntuneWinFile_textbox1.Text = $null;
			$upload2_DisplayName_textbox2.Text = $null;
			$upload2_Publisher_textbox1.Text = $null;
			$upload2_AppVersion_textbox1.Text = $null;
			$upload2_reglocation_textbox2.Text = $null;
			$upload2_regValue_textbox1.Text = $null;
			$upload2_installCMD_textbox1.Text = $null;
			$upload2_uninstallCMD_textbox1.Text = $null;
			$upload2_context_textbox1.Text = $null;
			
			$upload_panel2.Enabled = $false
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$upload_configLoaded_textbox3.Text = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			
			
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
		}
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2022 v5.8.210
	 Created on:   	26/02/2023 14:05
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
	.DESCRIPTION
		Params are used from IntunePrepTool
		Uses IntuneWin32App https://github.com/MSEndpointMgr/IntuneWin32App
		
#>

#Requires -RunAsAdministrator
#Installatie Powershell Modules
$RequiredPSModules = get-content "C:\Program Files\IntunePrepTool\InstallReqPSModules.txt"
if ($RequiredPSModules -like 'false') {
write-error 'Missing required Powershell Modules'
start-sleep 60
exit
}

[string]$config_csv_path = '!!CONFIGCSV!!'
[string]$buildingblocks_csv_path = '!!BUILDINGBLOCKSCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain') {
		$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
		$tenantID = $checkCredLoad.TargetName
		$tenantID = $tenantID.Split("_")[1]
		$AppId = $checkCredLoad.UserName
		$Secret = $checkCredLoad.Password
		}
		else {
		$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
		$tenantID = $cust.tenantID
		$AppId = $cust.appId
		$Secret = $cust.clientsecret

		}
	}
}

try
{
	Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret -ErrorAction Stop
}
catch
{
	Write-Error "No Connection to tenant. Please check app registration!!"
	start-sleep 60
	exit
}
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$regvalue = $ConfigCSVImport.RegValue
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
if ($ConfigCSVImport.context) {
$context = $ConfigCSVImport.context
}
else {
$context = 'system'
}

$logoaanwezig = get-childitem "$filepath\logo.png" -ErrorAction SilentlyContinue
if ($logoaanwezig -eq $null) { write-host "No Logo.PNG found in Output Directory" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
else
{
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}

	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName $regvalue -StringComparisonOperator equal -StringComparisonValue $versie
	$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
	write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam -Verbose
	if ($Win32AppEvtVorigeVersies -ne $null)
	{
		write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
		write-host $evtvversie
		$alversieAppAanwezig = $true;
		write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	}
	
	else
	{
		$alversieAppAanwezig = $false;
	}
	
	write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	 if ($logoaanwezig -eq $null) { 
        $Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose }
    else
    {
	$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose
    }
	Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	
	if ($SetupLikeOldVersion -eq $true)
	{
   <#
	
	$response = read-host "Press q to do nothing, Any other key for setting up dependencies. Dependency will be the same if older version. (When exists)"
	$niksdoen = $response -eq "q"
	if ($niksdoen -eq $true) { write-host "Ok.. We won't do this" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		if ($dep -notlike $null)
		{
			$dependency = Get-IntuneWin32App | Where-Object { $_.Displayname -like $dep }
			$dep2 = New-IntuneWin32AppDependency -DependencyType AutoInstall -ID $dependency.Id
			Add-IntuneWin32AppDependency -ID $Win32App.Id -Dependency $dep2 -Confirm:$false
			write-host "Dependency done"; Write-host "`r`n"; Write-host "`r`n";
		}
		else { write-host "No dependency found in older version" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	}
#>
		
		if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
		else
		{
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
				$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
				$evtvversie = $vorigeversie.DisplayVersion
				
				if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host ""; Write-host "`r`n"; Write-host "`r`n"
					$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
					$niksdoen = $response -eq "q"
					if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
					else
					{
						write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
						Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
						try
						{
							Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
						}
						catch
						{
							Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
						}
					}
				}
			}
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Write-host "We will fix superseedence for:" -ForegroundColor Green
					$vorigeversie.displayVersion
					
					$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
					$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
					if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
					Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
				}
			}
			
			
			
		}
		
		
	}
	if ($AvailableAllUsers -eq $true)
	{
		
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll -Verbose
		
	}
	
	
	if ($RequiredAllDevices -eq $true)
	{
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll -Verbose
		
		
		
		
	}
	
'@
	function Get-CheckedNodes
	{
		param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes)
		
		foreach ($Node in $NodeCollection)
		{
			if ($Node.Checked)
			{
				[void]$CheckedNodes.Add($Node)
			}
			Get-CheckedNodes $Node.Nodes $CheckedNodes
		}
	}
	$CheckedNodes = New-Object System.Collections.ArrayList
	Get-CheckedNodes $upload_treeview2.Nodes $CheckedNodes
	[string]$config_csv_path = $upload_configLoaded_textbox3.Text
	foreach ($node in $CheckedNodes)
	{
		
		if ($config_csv_path -notlike '*BuildingBlocks.csv*')
		{
			$depWin = $upload_dep_textbox1.Text
			$tenantName = $node.Name
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
			if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
			}
			if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
			}
			if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
			}
			
			
			
			
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$tenant = $node.Name
			$uploadFile = $filepath + "\uploadIntune" + $tenant + ".ps1"
			$uploadIntuneFile | Out-File $uploadFile -Force
			
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -File $uploadFile"
				#powershell -file $filepath\uploadIntune.ps1
				#Start-Sleep 1
				#PowershellISEOnTop
			}
		}
		else
		{
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$tenantName = $node.Name
				$scriptPath = "C:\Program Files\IntunePrepTool\UploadToIntuneBuildingBlocksCSV.ps1"
				$args = "-NoProfile -File `"$scriptPath`" -buildingblocks_csv_path `"$config_csv_path`" -tenantname `"$tenantName`""
				
				if ($Upload_beschikbaar_all_users_checkbox1.Checked)
				{
					$args += " -AvailableAllUsers `"True`""
				}
				
				if ($upload_checkboxRequiredForAllDevice.Checked)
				{
					$args += " -RequiredAllDevices `"True`""
				}
				Write-Host $args
				Start-Process -FilePath "powershell.exe" -ArgumentList $args
				
			}
			
		}
		
		
	}
	
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$fid = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$fid\$wid\$vid\Output\logo.png" -ErrorAction Stop
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
	
	
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msi_output_textbox1.AppendText("`r`n")
	$msi_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
function Show-NotifyIcon
{
<#
	.SYNOPSIS
		Displays a NotifyIcon's balloon tip message in the taskbar's notification area.
	
	.DESCRIPTION
		Displays a NotifyIcon's a balloon tip message in the taskbar's notification area.
		
	.PARAMETER NotifyIcon
     	The NotifyIcon control that will be displayed.
	
	.PARAMETER BalloonTipText
     	Sets the text to display in the balloon tip.
	
	.PARAMETER BalloonTipTitle
		Sets the Title to display in the balloon tip.
	
	.PARAMETER BalloonTipIcon	
		The icon to display in the ballon tip.
	
	.PARAMETER Timeout	
		The time the ToolTip Balloon will remain visible in milliseconds. 
		Default: 0 - Uses windows default.
#>
	 param(
	  [Parameter(Mandatory = $true, Position = 0)]
	  [ValidateNotNull()]
	  [System.Windows.Forms.NotifyIcon]$NotifyIcon,
	  [Parameter(Mandatory = $true, Position = 1)]
	  [ValidateNotNullOrEmpty()]
	  [String]$BalloonTipText,
	  [Parameter(Position = 2)]
	  [String]$BalloonTipTitle = '',
	  [Parameter(Position = 3)]
	  [System.Windows.Forms.ToolTipIcon]$BalloonTipIcon = 'None',
	  [Parameter(Position = 4)]
	  [int]$Timeout = 0
 	)
	
	if($null -eq $NotifyIcon.Icon)
	{
		#Set a Default Icon otherwise the balloon will not show
		$NotifyIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon([System.Windows.Forms.Application]::ExecutablePath)
	}
	
	$NotifyIcon.ShowBalloonTip($Timeout, $BalloonTipTitle, $BalloonTipText, $BalloonTipIcon)
}




<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
		[ValidateNotNull()]
		[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
		[ValidateNotNull()]
		[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		$Item,
		[Parameter(Mandatory = $false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView])
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param (
		$InputObject,
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterCIMProperties)
	
	if ($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @( ,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			$config_buildingblocks_textbox3.Text = $cis.buildingblockspath
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
			try
			{
				New-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script
			}
		
			$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
	$config_buildingblocks_textbox3.Text = "Enter local path where Building Blocks will be stored; Example c:\BuildingBlocks\"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					downloadpath    = $cis.downloadpath
					buildingblockspath = $cis.buildingblockspath
				})
		}
		
		
	}
	
	
	
	
	
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkName = $weblinkName -replace (" ", "")
	$weblink_packagename.Text = $weblinkName
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click = {
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			$wid = $winget_WingetID_textbox1.text
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			$WinGetID = $wid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	21-4-2025 20:44
 	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$version = "!!version!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution.
	### Ultimately, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $True
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath)
{
	$WingetPath = $ResolveWingetPath[-1].Path
	$wingetexe = $ResolveWingetPath
}
if (Test-path $WingetPath -ErrorAction SilentlyContinue)
{
	
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 1
	$versionW = & $wingetexe --version
	Write-Host $versionW
}
else
{
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 2
	$versionW = winget --version
	write-host $versionW
}


if ($versionW -notlike 'v*')
{
	Write-Host "Winget Version does not match.. installing now"
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
	$msixUrl = "https://github.com/microsoft/winget-cli/releases/download/v1.10.340/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	$msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	(New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)
	
	try
	{
		Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
		Write-Host "Winget installation completed successfully."
	}
	catch
	{
		if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop")
		{
			Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
			[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
			$dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.10.340/DesktopAppInstaller_Dependencies.zip'
			$dependencyPath = "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			(New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
			unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
			write-host "Now installing dependency"
			try
			{
				Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
				write-host "Installing depedency done"
			}
			catch
			{
				Write-host "Installing depedency failed"
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
			try
			{
				write-host "Now trying to install Winget again"
				Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
				write-host "Install winget done"
			}
			catch
			{
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
		}
		else
		{
			Write-Host "An unexpected error occurred: $($_.Exception.Message)"
		}
	}
	$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
	if ($ResolveWingetPath)
	{
		$WingetPath = $ResolveWingetPath[-1].Path
	}
	$wingetexe = $ResolveWingetPath
	
	if (Test-path $wingetexe)
	{
		
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 1
		$versionW = & $wingetexe --version
		Write-Host $versionW
	}
	else
	{
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 2
		$versionW = winget --version
		write-host $versionW
	}
}
else
{
	write-host "Winget already active"
}


try
{
	if ($wingetOption -eq 1)
	{
		$install = "!!WingetCommand!!"
		if ($install -like "!!doe*")
		{
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
			{
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
				
			}
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
			{
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
				
			}
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
			{
				
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
				
			}
			
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
			{
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
			}
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
			
			
		}
		else
		{
			& $wingetexe uninstall --id $WinGetID -h
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
		}
	}
	else
	{
		$install = "!!WingetCommand!!"
		if ($install -like "!!doe*")
		{
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
			{
				winget -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
				
			}
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
			{
				winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
				
			}
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
			{
				
				winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
				
			}
			
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
			{
				winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
			}
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
			
		}
		else
		{
			winget uninstall --id $WinGetID -h
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
		}
	}
}
catch
{
	
}

if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
	
}
#### Place extra actions here:







Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }



'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!version!!', $version)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$wingetID\$version\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$wingetID\$version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$wingetID\$version\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
			$winget_final_panel7.Enabled = $true
		}
	}
	
}

$winget_test_install_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_gotobuildingBlocks_buttonTestInstallPowershel.Enabled = $true
}

$winget_uninstall_test_button_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB.Enabled = $true
	
}

$winget_show_version_button1_Click = {
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click = {
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			
			
			
			
			
			
			
		}
		
	}
	
	
	
	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click = {
	#TODO: Place custom script here
	if ($config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click = {
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click = {
	#TODO: Place custom script here
	$upload_logo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $upload_logo_openfiledialog1.FileNames
	
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	
	$itwnf = $ConfigCSVImport.IntuneWinFile
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$filepath\logo.png"
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
}

$timer1_Tick = {
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click = {
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$toolstripstatuslabel1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
	
	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}

$chocolateyFindToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}
$chocolateyFindToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$chocolateyToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}




$fileWizzardToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'

	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}






$Weblink_intunewin_tabpage6_Click = {
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click = {
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
				
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile)
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
		
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
		
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click = {
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_name = $package_scheduledTask_name -replace (" ", "")
				$powershell_package_name_textbox1.Text = $package_scheduledTask_name
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
				
				
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click = {
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	6-10-2024 17:54
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -executionpolicy bypass -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Settings $settings -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				Write-Host "Eerste stap"
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			Write-Host "Check"
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
			
			if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
			}
			
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			Write-Host "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
			
		}
		
		
		
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
			}
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click = {
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

#Nuget installation
$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
$nugetInstallPath = "$env:ProgramFiles\NuGet"
if (-not (Test-Path -Path $nugetInstallPath))
{
	New-Item -ItemType Directory -Path $nugetInstallPath -Force
}
$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
if (Test-Path -Path $nugetExePath)
{
	Write-Host "NuGet has been installed successfully at $nugetExePath"
}
else
{
	Write-Host "NuGet installation failed"
}
$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
if ($path -notlike "*$nugetInstallPath*")
{
	[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
	Write-Host "NuGet has been added to the system PATH"
}
else
{
	Write-Host "NuGet is already in the system PATH"
}
& $nugetExePath | Select-String "NuGet Version"


Get-PackageProvider -Name Nuget -Force

#Installation Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Write-Host "IntuneWin32App 1.4.4 already installed"
	}
	else
	{
		Write-Host "Required Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Authentication 2.27.0 already installed"
	}
	else
	{
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Applications 2.27.0 already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		Write-Host "CredentialManager 2.0.0 Powershell module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Identity.SignIns 2.27.0 Powershell Module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
	
}

'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click = {
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click = {
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click = {
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click = {
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$download_winget_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click = {
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click = {
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click = {
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click = {
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click = {
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
		
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		try
		{
			$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUbinstall.ps1 NOT created `r`n")
		}
	}
}

$exe_radiobutton3_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $powershell_package_name_textbox1.text
	$exeversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if ([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$exepnaam\$exeversie\output\config.csv file there", 'Upload Now?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
		
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$buttonUser_folder_showInfo_Click = {
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
		
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click = {
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
}

$addTenantToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked = [System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click = {
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click = {
	#TODO: Place custom script here
	
	$tenantName = $config_tenant_name_textbox3.Text
	$tenantName  = $tenantName -replace (" ", "")
	
	$appRegName = $config_tenant_appRegName_textbox3.Text
	$appRegName = $appRegName -replace (" ", "")
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant with Global Admin rights. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		if ($config_add_Tenant_radiobutton1.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppReg.exe" -appRegName $appRegName -customername $tenantName
		}
		if ($config_add_Tenant_radiobutton2.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe" -appRegName $appRegName -customername $tenantName
		}
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		refreshTenantsUpload
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click = {
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click = {
	
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click = {
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click = {
	#TODO: Place custom script here
	$config_install_required_winget= @'
# Resolve Winget path
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath) {
    $WingetPath = $ResolveWingetPath[-1].Path
}
$wingetexe = $ResolveWingetPath

# Check Winget version
if (Test-path $wingetexe) {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 1
    $version = & $wingetexe --version
    Write-Host $version
} else {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 2
    $version = winget --version
    Write-Host $version
}

# Install Winget if needed
if ($version -notlike 'v1.10.340') {
    Write-Host "Winget Version does not match.. installing now"
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    $msixUrl  = "https://github.com/microsoft/winget-cli/releases/download/v1.10.340/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    $msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    (New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)

    try {
        Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
        Write-Host "Winget installation completed successfully."
    } catch {
        if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop") {
            Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            $dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.10.340/DesktopAppInstaller_Dependencies.zip'
            $dependencyPath =  "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            (New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
            unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
            write-host "Now installing dependency"
            try {
            Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
            write-host "Installing depedency done"
            }
            catch {
            Write-host "Installing depedency failed"
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
            try {
            write-host "Now trying to install Winget again"
            Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
            write-host "Install winget done" 
            }
            catch {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
        } else {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
        }
    }

    # Re-check Winget version after attempted install
    $ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
    if ($ResolveWingetPath) {
        $WingetPath = $ResolveWingetPath[-1].Path
    }
    $wingetexe = $ResolveWingetPath

    if (Test-path $wingetexe) {
        Write-Host "Re-checking Winget version..."
        $version = & $wingetexe --version
        Write-Host $version
    } else {
        Write-Host "Winget executable could not be found after installation attempt."
    }
} else {
    Write-Host "Winget is already up to date."
}

'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -PathType Leaf))
		{
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -Confirm:$false -Force
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installWinget.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
	
	
	
	
	#Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click = {
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
	
}

$MSIX_CreateScripts_button2_Click = {
	
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	#$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
	
	
}

$msix_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_GotoBuildingBlocks_Button.Enabled = $true
	}
}

$MSIX_test_uninstall_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB.Enabled = $true
	}
}

$MSIX_create_uninstall_Script_button2_Click = {
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName)
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click = {
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	$msix_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $msix_buildingblocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$exe_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$exe_output_textbox1.AppendText("$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv `r`n")
		$exe_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
}

$MSIX_UploadLogo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$msixpnaam\$msixversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$powershell_open_install_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellpnaam = $powershellpnaam -replace (" ", "")
	$powershell_packagename_textbox.text = $powershellpnaam
	$powershellversie = $powershell_packageversion_textbox.Text
	
	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click = {
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		if (($powershell_radiobutton2.Checked -eq $false) -and ($powershell_radiobutton1.Checked -eq $false))
		{
			[void][System.Windows.Forms.MessageBox]::Show('Select user or system context first', 'Please select user or system context first')
		}
		else
		{
			
			$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
			
			$powershelll_user_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1  }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
			$powershelll_user_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1  }
else { remove-item $regkeyApp; exit 0 }
'@
			
if ($powershell_radiobutton2.Checked -eq $true)
	{
	$powershelll_installFile = $powershelll_user_installFile
	$powershell_uninstallFile = $powershelll_user_uninstallFile
	}
	if ($powershell_radiobutton1.Checked -eq $true) {
	$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
			$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
				
			}
			
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
			$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
			$powershellpnaam = $powershell_packagename_textbox.text
			$powershellversie = $powershell_packageversion_textbox.Text
			$fid = $config_packagefolder; $outputDirectory = $fid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_install_org_path -Confirm:$false
			$powershellInputInstall = Get-Content -Path $powershell_install_org_path
			#Write-Host $powershellInputInstall
		
			$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
			$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
			$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			foreach ($line in $powershelll_installFile)
			{
				if ($line -like "#PowershellInstallStart*")
				{
					
					foreach ($inputLine in $powershellInputInstall)
					{
						
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
				
				
			}
				
			
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			
			
			
			
			
			
			[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
			$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
			$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			foreach ($line in $powershell_uninstallFile)
			{
				if ($line -like '#PowershellUninstallStart*')
				{
					
					foreach ($inputLine in $powershellInputUNInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
				
				
			}
			$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
			$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
			$Powershell_testUnInstall_button2.Enabled = $true
			$Powershell_testUnInstall_button2.Visible = $true
			$Powershell_testInstall_button2.Enabled = $true
			$Powershell_testInstall_button2.Visible = $true
			$Powershell_CreateIntuneWIn_button2.Enabled = $true
			$Powershell_CreateIntuneWIn_button2.Visible = $true
			
		}
	}

}

$powershell_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\install.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_testUnInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\uninstall.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_CreateIntuneWIn_button2_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	if ($32or64 -like "32 Bit Mode")
	{
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	else
	{
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		if ($32or64 -like "32 Bit Mode")
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		}
		else
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\$RegisterDetectionroot\"
		}
		
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Version' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
		[string]$context
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$context = 'user'
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$context = 'system'
	}
	$IntuneWinPackageConfig = $null;
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $true)
	{
		$icmd = '%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
		$ucmd = 'SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
	}
	else
	{
		$icmd = "powershell -executionpolicy bypass -file install.ps1"
		$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
	}
	
	
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = $icmd
			uninstallCMD  = $ucmd
			context		  = $context
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("When needed upload Logo to upload *.png file. `r`n")
	$powershell_output_textbox5.AppendText("Then use this config.csv in the upload tab to upload package to Intune. `r`n")
}

$Powershell_upload_logo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$powershellpnaam\$powershellversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
	$powershell_output_textbox5.AppendText("`r`n")
	$powershell_output_textbox5.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$updatepackage_msi_open_config_button1_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click = {
	#TODO: Place custom script here
	
}

$labelAppName_Click = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged = {
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click = {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$updatepackage_msi_appname_new_textbox3.text = $powershellpnaam
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}



$exe_open_Azure_OpenAI_Example_button1_Click = {
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click = {
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
		
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key		       = $config_openAI_textbox6.Text
			endpointURL    = $config_openAI_textbox7.Text
			deploymentName = $config_openAI_textbox8.Text
			
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}


$config_openAI_help_Click = {
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"

}




$config_openAI_textbox8_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox6_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_radiobutton2_CheckedChanged={
	#TODO: Place custom script here
	
}

$updatePackageIntunewinToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$updatepackage_exe_open_config_button1_Click={
	#TODO: Place custom script here
	$update_exe_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$update_exe_appname_old_textbox5.Text = $ConfigCSVImport.DisplayName
	$update_exe_new_appname_textbox7.Text = $ConfigCSVImport.DisplayName
	$update_exe_appversion_old_textbox4.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$update_exe_customer_old_textbox3.Text = $updatepackage_customername
	$updatepackage_EXE_panel6.Enabled = $true
	$updatepackage_EXE_panel6.Visible = $true
	$update_exe_panel4.Visible = $true
	$update_exe_panel4.Enabled = $true
}

$update_exe_buttonStep2CloneToNewDirec_Click={
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($update_exe_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($update_exe_new_appversion_textbox6.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $update_exe_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $update_exe_new_appname_textbox7.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$update_exe_new_appname_textbox7.text = $powershellpnaam
		$powershellversie = $update_exe_new_appversion_textbox6.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_exe_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_exe_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $update_exe_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_exe_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appName =*') -or ($lni -like '$version  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$appName =*') -or ($lni -like 'Versie =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("Replace EXE file for newer version with a. EXE file with the same name or b. change the Install parameters below")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		<#
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		#>
		$update_exe_panel6.Enabled = $true
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		foreach ($lni2 in $installparameters)
		{
			if ($lni2 -like '$exeParameters =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exeparameters2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exeparameters2 = $null
				}
				$exeparameters2 = $exeparameters2 -replace "^ ", ""
				$exeparameters2 = $exeparameters2.split("#")[0]
				$update_exe_installPar_textbox3.Text = $exeparameters2
			}
			if ($lni2 -like '$exeFile =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exefilename2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exefilename2 = $null
				}
				$exefilename2 = $exefilename2 -replace "^ ", ""
				
				$update_exe_Exefilename_textbox3.Text = $exefilename2
			}
			
		}

	
		$IsThisLineThereInUninstall = $old_uninstallps1 | ForEach-Object {
			if ($_ -match 'Please see u\.cmd for MSI parameters used by this script')
			{
				$_.Trim() 
			}
		} | Where-Object { $_ }
		if ($IsThisLineThereInUninstall)
		{
			Write-Host "De regel is aanwezig: $IsThisLineThereInUninstall"
			$update_exe_uninstall_panel6.Enabled = $false
			$update_exe_uninstall_panel6.Visible = $false
			$update_Exe_Uninstall_MSI_panel6.Enabled = $true
			$update_Exe_Uninstall_MSI_panel6.Visible = $true
			$update_exe_msi_uninstallcommandsOld = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\u.cmd"
			$udpdate_exe_msi_uninstall_textbox4.Text = $update_exe_msi_uninstallcommandsOld
			[void][System.Windows.Forms.MessageBox]::Show('See Find Uninstall String in the tools menu to search for new uninstall productcode and change the uninstall parameters after testing installation', 'Change uninstall string')
			
		}
		else
		{
			$oldInstallExeFilename = $old_installps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeFilename = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeParameters = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeParameters\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			#Write-Host "Old Install EXE Filename: $oldInstallExeFilename"
			#Write-Host "Old Uninstall EXE Filename: $oldUnInstallExeFilename"
			if ($oldInstallExeFilename -like $oldUnInstallExeFilename)
			{
				#Write-Host "Same EXE as install: $oldUnInstallExeFilename)"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
			Else
			{
				#Write-Host "Uninstall EXE path is $oldUnInstallExeFilename"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
		}
		
		
		
	}
}

$update_exe_buttonStep3OpenSourceDirec_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	$update_exe_buttonStep4SaveInstallPara.Enabled = $true
}

$update_exe_buttonStep4SaveInstallPara_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$installparameters = Get-Content "$newpackage_sourcepath\install.ps1"
	Remove-Item "$newpackage_sourcepath\install.ps1"
	foreach ($lni2 in $installparameters)
	{
		if (($lni2 -like '$exeParameters =*') -or ($lni2 -like '$exeFile =*'))
		{
			
			
			if ($lni2 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_installPar_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
			if ($lni2 -like '$exeFile =*')
			{
				
				'$exeFile = ' + $update_exe_Exefilename_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
		}
		else
		{
			$lni2 | Out-File "$newpackage_sourcepath\install.ps1" -Append
		}
		
	}
	$update_exe_buttonStep5TestAndEditInst.Enabled = $true
}

$update_exe_buttonStep5TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\install.ps1"
	
}

$buttonStep7TestAndEditUnin_Click={
	#TODO: Place custom script here
	
}

$update_exe_uninstall_msi_save_button3_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$udpdate_exe_msi_uninstall_textbox4.Text | Out-File "$newpackage_sourcepath\u.cmd" -Force
	$update_exe_uninstall_MSI_Test_button2.Enabled = $true
}

$update_exe_uninstall_MSI_Test_button2_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$buttonStep6SaveUninstallPa_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$uninstall_exe_uninstall = Get-Content "$newpackage_sourcepath\uninstall.ps1"
	Remove-Item "$newpackage_sourcepath\uninstall.ps1" -Confirm:$false -Force
	foreach ($lni5 in $uninstall_exe_uninstall)
	{
		if (($lni5 -like '$exeFile =*') -or ($lni5 -like '$exeParameters =*'))
		{
			if ($lni5 -like '$exeFile =*')
			{
				'$exeFile = ' + $update_exe_filetpathUninstall_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
			if ($lni5 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_uninstall_parameters_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
		}
		else
		{
			$lni5 | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			
		}
		
	}
	$update_exe_testuninstall_exe_buttonStep7TestAndEditInst.Enabled = $true
	
}

$update_exe_testuninstall_exe_buttonStep7TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$update_exe_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $update_exe_new_appname_textbox7.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_exe_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_exe_output_textbox4.AppendText("`r`n")
	
	$updatepackage_exe_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
}


$tools_choco_search_button2_Click={
	#TODO: Place custom script here
	
	
	function chocoSearch
	{
		param (
			[Parameter(Mandatory = $true)]
			[string]$name,
			[bool]$approvedOnly = $false
		)
		
		$chocoSearch = choco find $name --order-by-popularity
		if ($chocoSearch.Count -gt 2)
		{
			$chocoSearch = $chocoSearch[1 .. ($chocoSearch.Count - 2)]
		}
		
		$results = @()
		
		foreach ($ch in $chocoSearch)
		{
			$splitLine = $ch.Split(" ", 3, [System.StringSplitOptions]::RemoveEmptyEntries)
			if ($splitLine.Count -lt 2)
			{
				continue
			}
			
			$currentName = $splitLine[0]
			$currentVersion = $splitLine[1]
			$remaining = ""
			if ($splitLine.Count -eq 3)
			{
				$remaining = $splitLine[2]
			}
			if ($ch -match 'found|know|Learn')
			{
				continue
			}
			$isApproved = ($remaining -match '\[Approved\]')
			if ($approvedOnly -and -not $isApproved)
			{
				continue
			}
			$obj = [pscustomobject]@{
				Name	 = $currentName
				Version  = $currentVersion
				Approved = $isApproved
			}
			
			$results += $obj
		}
		
		return $results
	}
	$sChoco = $tools_choco_search_textbox3.Text
	
	
	if ($tools_choco_checkbox1.Checked -eq $true)
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $true
	}
	else
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $false
	}
	try
	{
		New-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script
	}
	

	$tools_choco_treeview2.BeginUpdate()
	$tools_choco_treeview2.Refresh()
	$tools_choco_treeview2.Nodes.Clear()
	#$tools_choco_treeview2.CheckBoxes = $true
	$Root = $tools_choco_treeview2.Nodes.Add("Choco Packages")
	foreach ($p in $chocoOutput)
	{
		#$upload_treeview2.Nodes.Add($tenantCSV.customername)
		$node = $Root.Nodes.Add($p.Name)
		
		$node.ContextMenuStrip = $tools_choco_contextmenustrip1
		#$node.Tag = $tenantCSV.target
		$node.Name = $p.Name
		
		
	}
	$Root.Expand()
	$tools_choco_treeview2.EndUpdate()
}

$config_tenants_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}



$tools_choco_contextmenustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$choco_toolstripmenuitem1_Click= {
	#TODO: Place custom script here
	

}
$tools_choco_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$chocoAll = Get-Variable -Name 'chocoOutput2' -Scope Script -ValueOnly
	$tools_choco_details_richtextbox1.text = ""
	
	foreach ($ch1 in $chocoAll)
	{
		if ($ch1.Name -eq $tools_choco_treeview2.SelectedNode.Name)
		{
			$tools_choco_panel6.Enabled = $true
			$tools_choco_selected_label6.Enabled = $true
			$tools_choco_selected_label6.Visible = $true
			$tools_choco_selected_label6.Text = $ch1.Name
			$chocoDetails = choco find $ch1.Name --exact --detail
			foreach ($ch2 in $chocoDetails)
			{
				$tools_choco_details_richtextbox1.AppendText("`r`n")
				$tools_choco_details_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}



$tools_choco_createdir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $tools_choco_displayname_textbox3.text
	$exeversie = $tools_choco_appversion_textbox3.text
	$exepnaam = $exepnaam -replace (" ", "")
	$tools_choco_displayname_textbox3.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$tools_choco_output_textbox3.Text = "`nNew package directory created: `r`n"
			$tools_choco_output_textbox3.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$tools_choco_output_textbox3.AppendText("`r`n")
			$tools_choco_panel7.Enabled = $true
			$tools_choco_open_PackageDir_button2.Enabled = $true
		}
	}
}
$tools_choco_displayname_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_appversion_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_createscriots_button2_Click={
	#TODO: Place custom script here
	$choco_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:19
	 Created by:   	Rink Turksma
	 Organization: 	https://githhub.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"
$paramsChoco = "!!paramsChocho!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
if (!(test-path -Path "$env:programdata\chocolatey"))
	{
		write-host "Installing Chocolatey"
		[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
	}


write-host "Now installing: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green
try
{
	write-host "Choco installation started" -ForegroundColor Green
	if ($paramsChoco -eq 'false')
	{
		choco install $chocoName --exact --yes --force
	}
	else
	{
		choco install $chocoName --exact --params $paramsChoco --yes --force
	}
	write-host "Installation success" -ForegroundColor Green
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	write-host "Now creating weekly scheduled task to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Monday -At 10:00
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}

if ($startupUpdateTask -eq 'true')
{
	write-host "Now creating scheduled task at startup to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -AtStartup
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}


try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	$choco_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:25
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
write-host "Now uninstalling: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green




try
{
	write-host "Choco uninstallation started" -ForegroundColor Green
	choco uninstall $chocoName --exact --yes --force
	write-host "UnInstallation success" -ForegroundColor Green
}
catch
{
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}
if ($startupUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000)
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$RegisterDetectionroot = "Intune_" + $config_customername
	$appVersion = $tools_choco_appversion_textbox3.text
	$appName = '"' + $tools_choco_displayname_textbox3.text + '"'
	$appName2 = $tools_choco_displayname_textbox3.text
	$chocoName = $tools_choco_selected_label6.Text
	
	$choco_installFile  = $choco_installFile.Replace('"!!AppName!!"', $appName)
	$choco_installFile  = $choco_installFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_installFile  = $choco_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_installFile  = $choco_installFile.Replace('!!version!!', $appVersion)
	$choco_installFile = $choco_installFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true' 
	$choco_installFile = $choco_installFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true) { $paramschoco = $tools_choco_parammstextbox3.Text; $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', $paramschoco) }
	else { $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', 'false') }
	try
	{
		$choco_installFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$appName2\$appVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	$choco_uninstallFile = $choco_uninstallFile.Replace('"!!AppName!!"', $appName)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!version!!', $appVersion)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true'
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	try
	{
		$choco_uninstallFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\uninstall.ps1" -Force -ErrorAction Stop
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
		$tools_choco_panel11.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 NOT created `r`n")
	}
}

$tools_choco_open_PackageDir_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$AppVersion = $tools_choco_appversion_textbox3.text
	Invoke-Item "$config_packagefolder\$appName\$appVersion\"
}

$tools_choco_testinstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$appName = $tools_choco_displayname_textbox3.text
		$appVersion = $tools_choco_appversion_textbox3.text
		powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$tools_choco_testUNinstall_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	$tools_choco_addBuildingBlocksCSVButton.Enabled = $true
}

$config_download_Choco_MSIX_bundle_Click={
	#TODO: Place custom script here
	
	$config_install_required_chocolatey = @'
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$picturebox1_Click={
	#TODO: Place custom script here
	
}

$tools_choco_AddParams_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true)
	{
		$tools_choco_parammstextbox3.Enabled = $true
		$tools_choco_parammstextbox3.Visible = $true
	}
	else
	{
		$tools_choco_parammstextbox3.Enabled = $false
		$tools_choco_parammstextbox3.Visible = $false
	}
}

$tools_choco_create_intunewin_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$appName\$appVersion\source\" -s "$config_packagefolder\$appName\$appVersion\source\install.ps1" -o "$config_packagefolder\$appName\$appVersion\output\" -q
	Rename-Item -Path "$config_packagefolder\$appName\$appVersion\output\install.intunewin" -NewName "$config_packagefolder\$appName\$appVersion\output\$appName.intunewin"
	$tools_choco_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\$appName.intunewin")
	$tools_choco_output_textbox3.AppendText("`r`n")
	
	$tools_choco_output_textbox3.AppendText("Install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("un-install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$appName\"
	$regkeyApp
	$tools_choco_output_textbox3.AppendText("$regkeyApp `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: $appVersion `r`n")
	$tools_choco_output_textbox3.AppendText("Please reopen tool to make another Chocolatey package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$appName.intunewin"
			DisplayName   = $appName
			Publisher	  = $config_customername
			AppVersion    = $appVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$appName\$appVersion\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$appName\$appVersion\output\"
	$tools_choco_output_textbox3.AppendText("Config.csv written to naar: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\config.csv")
	$tools_choco_output_textbox3.AppendText("  `r`n")
	$tools_choco_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$tools_choco_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $choco_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$appName\$appVersion\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appName\BuildingBlocks.csv" -force -NoTypeInformation
		$tools_choco_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$tools_choco_output_textbox3.AppendText("$config_buildingblockspath\$appName\BuildingBlocks.csv `r`n")
		$tools_choco_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
}

$tools_choco__upload_logo_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$appName\$appVersion\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$tools_choco_output_textbox3.AppendText("`r`n")
	$tools_choco_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}

$winget_search_button2_Click={
	$downloadWingetSearchText = $winget_search_textbox3.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$winget_output_textbox3.Text = $null
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	$winget_search_treeview2.BeginUpdate()
	$winget_search_treeview2.Refresh()
	$winget_search_treeview2.Nodes.Clear()
	$Root = $winget_search_treeview2.Nodes.Add("Winget Packages")
	$wingetOutp1 = @()
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp2 = $row_download_winget | Select ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp1 += [PSCustomObject]@{ ID = $wingetOutp2 }
				$node = $Root.Nodes.Add($download_winget_listboxInput)
				$node.Name = $wingetOutp2
			}
			$table_download_winget.AcceptChanges();	
			
		}
		
	}
	$Root.Expand()
	$winget_search_treeview2.EndUpdate()
	try
	{
		New-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script
	}
	
	
}

$winget_search_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$wingetAll = Get-Variable -Name 'wingetOutput' -Scope Script -ValueOnly
	$winget_show_info_richtextbox1.text = $null;
	foreach ($ch1 in $wingetAll.ID)
	{
		if ($ch1 -eq $winget_search_treeview2.SelectedNode.Name)
		{
			#$tools_choco_panel6.Enabled = $true
			#$tools_choco_selected_label6.Enabled = $true
			#$tools_choco_selected_label6.Visible = $true
			#$tools_choco_selected_label6.Text = $ch1.Name
			#$winget_settings_panel7.Enabled = $true;
			$winget_selected_panel7.Enabled = $true
			$winget_createPackageDIR_panel7.Enabled = $true
			$wingetDetails = winget show --id $ch1
			$ch1 = $ch1.Replace('"','')
			$winget_WingetID_textbox1.Text = $ch1
			foreach ($ch2 in $wingetDetails)
			{
				$winget_show_info_richtextbox1.AppendText("`r`n")
				$winget_show_info_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}

$winget_CreatePackageDir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			
			
			$WinGetID = $winget_WingetID_textbox1.text
			
			$DisplayName = $winget_displayname_textbox1.text
		
			if (!(Test-Path -Path "$config_packagefolder\$WinGetID\$version\source"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$WinGetID\$version\source"
			}
			if (!(Test-Path -Path "$config_packagefoldery\$WinGetID\$version\output"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$wingetID\$version\output"
			}
			$winget_open_package_dir_button3.Enabled = $true
			$winget_settings_panel7.Enabled = $true
			
		}
	}
}
$winget_open_package_dir_button3_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$version = $versie_textbox2.Text
	$WinGetID = $winget_WingetID_textbox1.text
	Invoke-Item "$config_packagefolder\$WinGetID\$version"
}

$checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$radiobutton64Bit_CheckedChanged={
	#TODO: Place custom script here
	
}

$config_version_label1_Click={
	#TODO: Place custom script here
	
}

$config_install_sandbox_buttonInstallSanboxPowersh_Click={
	#TODO: Place custom script here
	$config_install_required_chocolatey = @'
Enable-WindowsOptionalFeature -FeatureName "Containers-DisposableClientVM" -All -Online
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$config_add_Tenant_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}



$registryToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$capture_registry_loadTreeview_button2_Click={
	#TODO: Place custom script here

		

	
	
}

$Registry_capture_panel7_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$capture_registry_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	#Source https://www.sapien.com/forums/viewtopic.php?t=11679
	if ($_.Node.Nodes.Count -eq 0)
	{
		foreach ($keyName in ($_.Node.Tag.GetSubkeyNames()))
		{
			Try
			{
				$regKey = $_.Node.Tag.OpenSubKey($keyName)
				$n = New-Object System.Windows.Forms.TreeNode
				$n.Name = $regKey.PsPath
				$n.Text = $keyName
				$n.Tag = $regKey
				$_.Node.Nodes.Add($n)
			}
			Catch
			{
				Write-Host $_
			}
		}
	}

}

$registry_capture_tabpage5_Click={
	#TODO: Place custom script here
	
}

$Registry_Capture_Step2_CreateBackup_button2_Click = {
	if ($registry_name_textbox3.Text -notlike $null)
	{
		
		$node = $capture_registry_treeview2.SelectedNode
		$nodeTexts = @()
		while ($node)
		{
			$nodeTexts += $node.Text
			$node = $node.Parent
		}
		$reversedNodeTexts = @()
		for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
		{
			$reversedNodeTexts += $nodeTexts[$i]
		}
		$rootHive = ""
		$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
		
		$RegistryCaptureScript = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	22-3-2025 20:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	regcompare.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$regexportpath = "!!regexportpath!!"
$backupFolder = "!!backupFolder!!"
if (!(Test-Path $backupFolder))
{
	New-Item -Path $backupFolder -ItemType Directory | Out-Null
}
$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$preBackupPath = Join-Path $backupFolder "PreChanges_$timeStamp.reg"
$postBackupPath = Join-Path $backupFolder "PostChanges_$timeStamp.reg"
$DiffRegName = "!!DiffRegName!!"
$diffPath = Join-Path $backupFolder "$DiffRegName`_$timeStamp.reg"

Write-Host "Exporting registry from: $regExportPath"  
Write-Host "Creating first registry backup (pre-changes)..."  
reg export "$regExportPath" "$preBackupPath" /y | Out-Null
Write-Host "  Pre-changes backup saved to: $preBackupPath`n"
Write-Host "Make any desired changes to your registry/application now." -ForegroundColor Green
Write-Host "Press ENTER when finished..." -ForegroundColor Green
Read-Host
Write-Host "`nCreating second registry backup (post-changes)..."  
reg export "$regExportPath" "$postBackupPath" /y | Out-Null
Write-Host "  Post-changes backup saved to: $postBackupPath`n"  
Write-Host "Now comparing backups to find differences..."  

function Compare-RegFiles
{
	param (
		[string]$OldRegPath,
		[string]$NewRegPath,
		[string]$DiffOutPath
	)
	
	$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
	$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
	$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
	$differences = New-Object System.Collections.Specialized.OrderedDictionary
	$currentKey = $null
	foreach ($line in $newLines)
	{
		if ($line -match '^\[\S+\]$')
		{
			$currentKey = $line
			continue
		}
		if ($line -match '^\S+=' -and $currentKey)
		{
			if (-not $oldHashSet.Contains($line))
			{
				if (-not $differences.Contains($currentKey))
				{
					$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
				}
				$differences[$currentKey].Add($line)
			}
		}
	}
	if ($differences.Count -gt 0)
	{
		Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
		foreach ($key in $differences.Keys)
		{
			Add-Content -Path $DiffOutPath -Value "`r`n$key"
			foreach ($val in $differences[$key])
			{
				Add-Content -Path $DiffOutPath -Value $val
			}
		}
		Write-Host "Differences found! Saved to: $DiffOutPath" -ForegroundColor Green
		$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
	}
	else
	{
		Write-Host "No differences detected."  
		if (Test-Path $DiffOutPath)
		{
			Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
		}
	}
}

Compare-RegFiles -OldRegPath $preBackupPath `
				 -NewRegPath $postBackupPath `
				 -DiffOutPath $diffPath


Write-Host "`nRemoving the two backup files..."  
Remove-Item -Path $preBackupPath -ErrorAction SilentlyContinue
Remove-Item -Path $postBackupPath -ErrorAction SilentlyContinue

Write-Host "`nAll done. Please close this Powershell_ISE window and continue in the IntunePrepTool"


'@
		if (Get-Process -Name "powershell_ise" -ErrorAction SilentlyContinue)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please close any existing Powershell_ISE windows, When done.. Start again', 'Please close existing Powershell_ISE windows')
		}
		else
		{
			
			if ($registry_name_textbox3.text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please select Name first, When done.. Start again', 'Please select Name first')
			}
			else
			{
				if ($Registry_HKLM_radiobutton1.Checked -eq $true)
				{
					$regName = "HKLM_"
				}
				if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
				{
					$regName = "HKCU_"
				}
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!regexportpath!!", $allNodesString)
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$BackupLocation = $config_packagefolder + '\' + "0_BuildingBlocks\Registry"
				$BackupLocation = $BackupLocation -replace ("\\", "\")
				$regName2 = $regName + $registry_name_textbox3.text
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!backupFolder!!", $BackupLocation)
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				
				
				if (!(Test-Path "C:\Program Files\IntunePrepTool\regcompare.ps1" -PathType Leaf))
				{
					$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
					powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
				else
				{
					try
					{
						Remove-Item "C:\Program Files\IntunePrepTool\regcompare.ps1" -Confirm:$false -ErrorAction Stop
						$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
						powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
						Start-Sleep 1
						PowershellISEOnTop
					}
					catch
					{
						[void][System.Windows.Forms.MessageBox]::Show('When done.. Start again', 'Please close existing Powershell_ISE windows')
					}
					
					
				}
			}
		}
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Enter name and start again please', 'Please enter Name first')
	}
	
	
	
}



$Registry_load_button2_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$capture_registry_treeview2.Refresh()
		$capture_registry_treeview2.Nodes.Clear()
		$capture_registry_treeview2.Refresh()
		if ($Registry_HKLM_radiobutton1.Checked -eq $true)
		{
			$regKey = Get-Item HKLM:\ -ErrorAction SilentlyContinue
		}
		if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
		{
			$regKey = Get-Item HKCU:\
		}
		
		$n = New-Object System.Windows.Forms.TreeNode
		$n.Name = $regKey.PsPath
		$n.Text = $regKey.Name
		$n.Tag = $regKey
		$capture_registry_treeview2.Nodes.Add($n)
		
		
	
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
	}
	
}

$registry_capture_label5_Click={
	#TODO: Place custom script here
	
}

$registry_name_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$registry_button2_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Please remove all irrelevant items and then click Save in Notepad.', 'Edit .reg file in Notepad')
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	notepad $regfile
	
}

$buttonStep6AddBuildingBloc_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$BackupLocation = $config_packagefolder + '\' + "1_BuildingBlocksPackages\Registry"
	$BackupLocation = $BackupLocation -replace ("\\", "\")
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	
	if ($Registry_HKLM_radiobutton1.Checked -eq $true)
	{
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show('In this case, a separate package is not needed. You can also add the created .reg file to your existing MSI, MSIX, or EXE package. Do you want to continue creating a separate package?', 'HKLM selected',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
			$systemoruser = "system"
			$regName = "HKLM_"
			$registry_output_textbox3.Text = "Creating Building Block Package in the System context"
			$registry_output_textbox3.AppendText("  `r`n")
			$BuildingBlockRegistrySystem = @'
if (Test-Path 'hklm.reg') {
    Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hklm.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}

'@
			$BackupLocation = $BackupLocation + "\system\"
			$regName2 = $regName + $registry_name_textbox3.text
			$BackupLocation = $BackupLocation + $regName2
			if (!(Test-Path $backupLocation))
			{
				New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
				$registry_output_textbox3.AppendText("$backupLocation created")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			else
			{
				$registry_output_textbox3.AppendText("$backupLocation already exists")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			$BuildingBlockRegistrySystem | Out-File "$BackupLocation\BuildingBlock.ps1"
			$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
			$registry_output_textbox3.AppendText("  `r`n")
			Copy-Item $regfile "$backupLocation\hklm.reg"
			$registry_output_textbox3.AppendText("hklm.reg created")
			$registry_output_textbox3.AppendText("  `r`n")
			$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the System Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
			$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
			
		}
	}
	if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
	{
		$systemoruser = "user"
		$regName = "HKCU_"
		$registry_output_textbox3.Text = "Creating Building Block Package in the User context"
		$registry_output_textbox3.AppendText("  `r`n")
		$BuildingBlockRegistryUser = @'
if (Test-Path 'hkcu.reg') {
    Write-Host "hkcu.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hkcu.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
		$BackupLocation = $BackupLocation + "\User\"
		$regName2 = $regName + $registry_name_textbox3.text
		$BackupLocation = $BackupLocation + $regName2
		if (!(Test-Path $backupLocation))
		{
			New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
			$registry_output_textbox3.AppendText("$backupLocation created")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		else
		{
			$registry_output_textbox3.AppendText("$backupLocation already exists")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		$BuildingBlockRegistryUser | Out-File "$BackupLocation\BuildingBlock.ps1"
		$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
		$registry_output_textbox3.AppendText("  `r`n")
		Copy-Item $regfile "$BackupLocation\hkcu.reg"
		$registry_output_textbox3.AppendText("hkcu.reg created")
		$registry_output_textbox3.AppendText("  `r`n")
		$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the User Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
		#$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
		
		
	}
	
	

	
	
	
	
}

$msi_addBuildBlock_regHKLM_Click={
	#TODO: Place custom script here
	<#
	$msi_add_HKLM_openfiledialog1.ShowDialog()
	$msi_reg_hklm_label5.Text = $msi_add_HKLM_openfiledialog1.SafeFileName
	$msi_reg_hklm_label5.Visible = $true
	$msi_reg_hklm_label5.Enabled = $true
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$paname = $msi_packagenaam_textbox1.text
	$paversion = $msi_versie_textbox1.text
	$selectedpadir = "$config_packagefolder\$paname\$paversion\source"
	$msi_output_textbox1.AppendText("`n.reg file will now be copied`r`n")
	[string]$msi_reg_hklm_org_path = $msi_add_HKLM_openfiledialog1.FileNames
	Copy-Item -Path $msi_reg_hklm_org_path -Destination "$selectedpadir\hklm.reg"
	$msi_output_textbox1.AppendText("`n.reg file copy done to HKLM.reg `r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("There`'s no need to recreate your install.ps1 script when already created. The created install.ps1 already checks for a file named 'hklm.reg' and imports it when available.", 'HKLM.reg file added') # Casting the method to [void] suppresses the output. 
	#>
}

$buttonOptionalOpenRegedit_Click={
	#TODO: Place custom script here
	regedit
}

$capture_registry_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$node = $capture_registry_treeview2.SelectedNode
	$nodeTexts = @()
	while ($node)
	{
		$nodeTexts += $node.Text
		$node = $node.Parent
	}
	$reversedNodeTexts = @()
	for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
	{
		$reversedNodeTexts += $nodeTexts[$i]
	}
	$rootHive = ""
	$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
	$registry_selected_textbox3.Text = $allNodesString
}

$Registry_OpenBuildingBLockLocationbutton2_Click={
	#TODO: Place custom script here
	explorer $registry_buidingblocksfiledir_textbox3.Text
}

$file_loadFolder_button2_Click={
	#TODO: Place custom script here
	$file_folderbrowsermoderndialog2.ShowDialog()
	$file_selected_source_folder_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
	$file_folder_destination_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
}

$hscrollbar1_Scroll=[System.Windows.Forms.ScrollEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ScrollEventArgs]
	#TODO: Place custom script here
	
}

$addFolderToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
	
	<#
	$file_folder_panel8.Enabled = $true
	$file_folder_panel8.Visible = $true
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
#>
	}

$file_folder_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false

}

$file_folder_add_button2_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
	
	if ($file_folder_skip_checkbox1.Checked -eq $true) {
		$file_folder_SKIP = $true
	}
	if ($file_folder_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_SKIP = $false
	}
	
	if ($file_folder_overwrite_checkbox1.Checked -eq $true)
	{
		$file_folder_overwrite = $true
	}
	if ($file_folder_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'folder';
	$row["Source"] = $file_selected_source_folder_textbox3.text;
	$row["Destination"] = $file_folder_destination_textbox3.Text;
	$row["Skip"] = $file_folder_SKIP;
	$row["Overwrite"] = $file_folder_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();
	## - Display custom data created:
	#$files_folders_datagridview1.DataSource = $table;
	
	
}

$config_tenant_info_secret_delete_button2_Click={
	#TODO: Place custom script here
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$file_file_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$addFileToolStripMenuItem_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $true
	$file_file_panel8.Visible = $true
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
}

$file_loadFile_button2_Click={
	#TODO: Place custom script here
	$file_file_openfiledialog1.ShowDialog()
	$file_selected_source_file_textbox3.Text = $file_file_openfiledialog1.FileNames
	$file_file_destination_textbox3.Text = $file_file_openfiledialog1.FileNames
}

$file_file_add_button2_Click={
	#TODO: Place custom script here
	if ($file_file_skip_checkbox1.Checked -eq $true)
	{
		$file_file_SKIP = $true
	}
	if ($file_file_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_file_SKIP = $false
	}
	
	if ($file_file_overwrite_checkbox1.Checked -eq $true)
	{
		$file_file_overwrite = $true
	}
	if ($file_file_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_file_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'file';
	$row["Source"] = $file_selected_source_file_textbox3.text;
	$row["Destination"] = $file_file_destination_textbox3.Text;
	$row["Skip"] = $file_file_SKIP ;
	$row["Overwrite"] = $file_file_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();

	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$showCompleteToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-ChildForm_psf) -eq 'OK')
	{
		
	}
}

$addRegistryToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$file_folder_tablelayoutpanel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$toolstripstatuslabel1_Click={
	#TODO: Place custom script here
	
}

$statusbar1_PanelClick=[System.Windows.Forms.StatusBarPanelClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.StatusBarPanelClickEventArgs]
	#TODO: Place custom script here
	
}

$user_folder_context_system_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}

$BuildingBlocks_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$building_blocks_show_Refresh_button1_Click={
	#TODO: Place custom script here
	
}

$buttonAddFileOrFolder_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage5
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
}

$buildingblocks_buttonAddRegistryCapture_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage6
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$buildingBlocks_clear_button1_Click={
	#TODO: Place custom script here
	$BuildingBlocksTable.Clear()
	$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
	$BuildingBlocksTable2.Clear()
	$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
	$BuildingBlocksTable3.Clear()
	$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
	
	#$buildingBlocks_panel85.Enabled = $false;
	$bb_usePackageInProgress_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $true
	$bb_usePackageInProgress_radiobutton1.Enabled = $true
	$buildingblocks_Name_textbox4.Text = $null
	$buildingblocks_version_textbox3.Text = $null
}

$tablelayoutpanel9_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$buildingblocks_add_Shortcuts_button1_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage7
	if ((Show-BuildingBlocksShortcut_psf) -eq 'OK')
	{
		
	}
}

$buttonBuild_Click={
	#TODO: Place custom script here
	if ($buildingblocks_Name_textbox4.Text -like $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Select name and try again please!", 'Please select a name for Building Blocks first') # Casting the method to [void] suppresses the output.
	}
	else
	{
		class IntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
			[string]$context
		}
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
		if ($config_buildingblockspath -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please add Building Blocks location for your customer in the Start / Config menu first", 'Building Blocks location missing!')
		}
		else
		{
			$BBAppName = $buildingblocks_Name_textbox4.Text
			if (Test-Path "$config_buildingblockspath\$BBAppName")
			{
				[void][System.Windows.Forms.MessageBox]::Show("Please remove $config_buildingblockspath\$BBAppName before you can continue", 'Location Already exists')
			}
			else
			{
				$bbSystemContext = $false
				$bbUserContext = $false
				$newNameBuildingBlocks = $buildingblocks_Name_textbox4.Text
				$newNameBuildingBlocks = $newNameBuildingBlocks -replace (' ', '')
				$buildingblocks_Name_textbox4.Text = $newNameBuildingBlocks
				$buildingblocks_output_textbox5.Text = "Building Block Name: $newNameBuildingBlocks"
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				$BuildingBlocksSystemLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\System"
				$BuildingBlocksSystemLocation = $BuildingBlocksSystemLocation -replace ("\\", "\")
				$BuildingBlocksUserLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\User" + "\BuildingBlocksData"
				$BuildingBlocksUserLocation = $BuildingBlocksUserLocation -replace ("\\", "\")
				$buildingBlockFolder = $config_buildingblockspath + '\' + $newNameBuildingBlocks
				$buildingBlockFolder = $buildingBlockFolder -replace ("\\", "\")
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show("IntunePrepTool may temporarily become unresponsive while creating the building blocks.", 'Please wait while the building block(s) are being created.') # Casting the method to [void] suppresses the output.
				$is = 1;
				$iu = 1;
				
				
				
				if ($BuildingBlocksTable -notlike $null)
				{
					
					foreach ($r in $BuildingBlocksTable)
					{
						$BuildingBlocksFilesAndFolders = @'
$sort = "!!sort!!"
$source = "!!source!!"
$destination = "!!destination!!"
$skip = "!!skip!!"
$overwrite = "!!overwrite!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot

if (($skip -eq $true) -and ($overwrite -eq $true))
{
	Write-Host "Overwrite takes precedence over skip."
	$skip = $false
}

if (($skip -eq $false) -and ($overwrite -eq $false))
{
	Write-Host "No Skip or Overwrite selected; Overwrite takes precedence over skip."
	$overwrite = $true
}

if ($overwrite -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				try
				{
					Copy-Item $_.FullName -Destination $targetPath -Force -ErrorAction Stop
					$fn = $_.FullName
					Write-Host "Copy from $fn to  $targetPath done!"
				}
				catch
				{
					$fn = $_.FullName
					Write-Error "Copy from $fn to  $targetPath failed!"
				}
				
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		try
		{
			Copy-Item $source -Destination $destination -Force -ErrorAction Stop
			Write-Host "Copy from $source to  $destination done!"
		}
		catch
		{
			Write-Error "Copy from $source to  $destination failed!"
		}
		
	}
}

if ($skip -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				if (-not (Test-Path $targetPath))
				{
					try
					{
						Copy-Item $_.FullName -Destination $targetPath -ErrorAction Stop
						$fn = $_.FullName
						Write-Host "Copy from $fn to $targetPath done!"
					}
					catch
					{
						Write-Error "Copy from $fn to $targetPath failed!"
					}
					
				}
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		if (-not (Test-Path $destination))
		{
			try
			{
				Copy-Item $source -Destination $destination -ErrorAction Stop
				Write-Host "Copy from $source to $destination done!"
			}
			catch
			{
				Write-Host "Copy from $source to $destination failed!"
			}
			
		}
	}
}
'@
						$BuildingBlocksFilesAndFoldersUninstall = @'
$sort = "!!sort!!"
$destination = "!!destination!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot
if ($sort -like 'folder') {
remove-item $destination -recurse -confirm:$false -force
}
if ($sort -like 'file') {
remove-item $destination -confirm:$false -force
}
write-host "Uninstall file or folder action done!"
'@
						
						if ($r["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the system context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\data"
							$BuildingBlocksISLocation = $BuildingBlocksISLocation -replace ("\\", "\")
							
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$sourceIs = $($r["Source"])
							$sourceIs = $sourceIs -replace ("\\", "\")
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIs.Split('\')[-1]
								$dest = $BuildingBlocksISLocation + "\$sourcefilename"
								Copy-Item $sourceIs -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Write-Host "Copy $sourceIs to $BuildingBlocksISLocation"
								Copy-Item "$sourceIs\*" -Destination $BuildingBlocksISLocation -Recurse -Container
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\i.ps1"
							
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							$is = $is + 1
						}
						if ($r["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the user context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\data"
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$sourceIu = $($r["Source"])
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIu.Split('\')[-1]
								$dest = $BuildingBlocksIULocation + "\$sourcefilename"
								Copy-Item $sourceIu -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Copy-Item "$sourceIU\*" -Destination $BuildingBlocksIULocation -Recurse
								
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\i.ps1"
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							
							$iu = $iu + 1
						}
						
					}
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No file or folder activity detected.")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable3 -notlike $null)
				{
					foreach ($r3 in $BuildingBlocksTable3)
					{
						
						$BuildingBlockRegistryScript = @'
Set-Location $PSScriptRoot
$regfilename = "!!regfilename!!"
if (Test-Path $regfilename) {
    $output = reg import $regfilename /reg:64 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Registry Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Registry Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
						$is = 1;
						$iu = 1;
						if ($r3["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\Registry$is"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$buildingblocks_output_textbox5.AppendText('Registry file is now being copied to Building Block Location')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksISLocation\hklm.reg" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hklm.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							
							$is = $is + 1
						}
						if ($r3["Context"] -like 'user')
						{
							$bbUserContext = $true
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\Registry$iu"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksIULocation\hkcu.reg" -force
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hkcu.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksIULocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$iu = $iu + 1
						}
						
						
						
						
					}
					$buildingblocks_output_textbox5.AppendText("Registry done")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Registry actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable2 -ne $Null)
				{
					$i = 1;
					foreach ($r2 in $BuildingBlocksTable2)
					{
						$BuildingBlockShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot
if ($Context -like 'user') {
    $folderPath = Join-Path $env:AppData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}
elseif ($Context -like 'system') {
    $folderPath = Join-Path $env:ProgramData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}


function fCreateShortcut
{
    <#
    .SYNOPSIS
    Creates a shortcut in the Desktop and/or Start Menu, for user or system context.

    .PARAMETER TargetFile
    The path to the executable or file the shortcut should point to.

    .PARAMETER ShortcutName
    The name of the shortcut (without .lnk extension).

    .PARAMETER Icon
    (Optional) Path to the icon file.

    .PARAMETER ShortcutArguments
    (Optional) Arguments to pass to the target.

    .PARAMETER Location
    One or more of 'Desktop' and/or 'StartMenu'.

    .PARAMETER Scope
    'User' or 'System' (default is 'User').

    .PARAMETER Subfolder
    (Optional) Subfolder within the Desktop or Start Menu path.
    #>
	
	param (
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[Parameter(Mandatory = $true)]
		[string]$ShortcutName,
		[string]$Icon = "",
		[string]$ShortcutArguments = "",
		[Parameter(Mandatory = $true)]
		[ValidateSet("Desktop", "StartMenu")]
		[string[]]$Location,
		[ValidateSet("User", "System")]
		[string]$Scope = "User",
		[string]$Subfolder = ""
	)
	
	$WorkingDir = Split-Path -Path $TargetFile -Parent
	
	foreach ($loc in $Location)
	{
		switch ($Scope)
		{
			'User' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { [Environment]::GetFolderPath("Desktop") }
					'StartMenu' { [Environment]::GetFolderPath("StartMenu") }
				}
			}
			'System' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { "$env:PUBLIC\Desktop" }
					'StartMenu' { "$env:ProgramData\Microsoft\Windows\Start Menu\Programs" }
				}
			}
		}
		
		$FullPath = if ($Subfolder)
		{
			Join-Path -Path $BasePath -ChildPath $Subfolder
		}
		else
		{
			$BasePath
		}
		if (-not (Test-Path $FullPath))
		{
			New-Item -Path $FullPath -ItemType Directory -Force | Out-Null
		}
		$ShortcutPath = Join-Path -Path $FullPath -ChildPath "$ShortcutName.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutPath)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.WorkingDirectory = $WorkingDir
		if ($Icon)
		{
			$Shortcut.IconLocation = $Icon
		}
		if ($ShortcutArguments)
		{
			$Shortcut.Arguments = $ShortcutArguments
		}
		$Shortcut.Save()
	}
}

if ($Desktop -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location Desktop `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments `
                    -Subfolder $Subfolder
Write-Host "Shortcut created successfully in: Desktop"
}

if ($StartMenu -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location StartMenu `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments

}
Write-Host "Shortcut created successfully in: Startmenu"
'@
						$BuildingBlockUninstallShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot

$Locations = @()
if ($Desktop)   { $Locations += 'Desktop' }
if ($StartMenu) { $Locations += 'StartMenu' }

foreach ($loc in $Locations)
{
    switch ($Context) {
        'User' {
            $BasePath = switch ($loc) {
                'Desktop'   { [Environment]::GetFolderPath('Desktop') }
                'StartMenu' { [Environment]::GetFolderPath('StartMenu') }
            }
        }
        'System' {
            $BasePath = switch ($loc) {
                'Desktop'   { Join-Path $env:Public 'Desktop' }
                'StartMenu' { Join-Path $env:ProgramData 'Microsoft\Windows\Start Menu\Programs' }
            }
        }
    }
    $FullPath = if ($Subfolder) {
        Join-Path -Path $BasePath -ChildPath $Subfolder
    }
    else {
        $BasePath
    }
    $ShortcutPath = Join-Path -Path $FullPath -ChildPath ("$Name.lnk")
    if (Test-Path $ShortcutPath) {
        Remove-Item $ShortcutPath -Force
        Write-Host "Removed shortcut: $ShortcutPath"
    }
    if ((Test-Path $FullPath) -and !(Get-ChildItem -Path $FullPath -Force)) {
        Remove-Item $FullPath -Force
        Write-Host "Removed empty folder: $FullPath"
    }
}
if ($ICOFile)
{
    if ($Context -like 'user') {
        $iconFolderPath = Join-Path $env:AppData ".IntunePrepTool\ICONS"
    }
    elseif ($Context -like 'system') {
        $iconFolderPath = Join-Path $env:ProgramData ".IntunePrepTool\ICONS"
    }
    $destinationFile = Join-Path $iconFolderPath (Split-Path $ICOFile -Leaf)
    if (Test-Path $destinationFile) {
        Remove-Item $destinationFile -Force
        Write-Host "Removed icon: $destinationFile"
    }
}

Write-Host "`nUninstall script completed."
'@
						
						
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						if ($r2["Desktop"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $false)
						}
						if ($r2["Startmenu"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $false)
						}
						if ($r2["Context"] -like 'system')
						{
							$bbSystemContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\shortcut$i"
						}
						if ($r2["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksUserLocation + "\shortcut$i"
						}
						
						
						if (!(test-Path $BuildingBlocksISLocation))
						{
							New-Item -ItemType Directory -Path $BuildingBlocksISLocation
						}
						$icoName = -join (
							(97 .. 122) |
							Get-Random -Count 6 |
							ForEach-Object { [char]$_ }
						)
						$icoName = 'shortcut-' + $icoName
						$buildingblocks_output_textbox5.AppendText("Shortcut actions found!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						Copy-Item $($r2["ICO File"]) "$BuildingBlocksISLocation\$icoName.ico" -Force
						$buildingblocks_output_textbox5.AppendText('The ICO file (shortcut) is now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!icofile!!", $icoName)
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!icofile!!", $icoName)
						$buildingblocks_output_textbox5.AppendText('Scripts (shortcuts) are now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force
						$BuildingBlockUninstallShortcutScript | Out-File "$BuildingBlocksISLocation\u.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("done!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						
						
						
						
						$i = $i + 1
					}
					
					
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Shortcut actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				
				
				$buildingblocks_output_textbox5.AppendText("Building Blocks created: $buildingBlockFolder")
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				#$buildingBlocks_panel85.Enabled = $true;
				if ($bbUserContext -like $true)
				{
					$userContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextInstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
					$userContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
					$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the User Context Package...`r`n")
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					$RegisterDetectionroot = "Intune_" + $config_customername
					$userContext_installFile = $userContext_installFile.Replace('!!AppName!!', "$appname")
					$userContext_installFile = $userContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_installFile = $userContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_installFile = $userContext_installFile.Replace('!!version!!', $appversion)
					$userContext_installFile | Out-File "$config_buildingblockspath\$appname\User\install.ps1" -Force
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!AppName!!', "$appname")
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!version!!', $appversion)
					$userContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\User\uninstall.ps1" -Force
					$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show(
						'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
						'Creating User Context Package'
					) # Casting the method to [void] suppresses the output. 
					if (!(Test-Path "$config_buildingblockspath\$appname\output-UserContext\"))
					{
						mkdir "$config_buildingblockspath\$appname\output-UserContext\" -Force
					}
					
					
					& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\User\" -s "$config_buildingblockspath\$appname\User\install.ps1" -o "$config_buildingblockspath\$appname\output-UserContext\" -q
					Rename-Item -Path "$config_buildingblockspath\$appname\output-UserContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin"
					$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					
					$context = 'user'
					$icmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File install.ps1"
					$ucmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File uninstall.ps1"
					$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
					$regkeyApp = "$regkeyRoot$appname"
					$usercontextVersion = $appversion + "user"
					$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
							IntuneWinFile = "$appname.intunewin"
							DisplayName   = $appname
							Publisher	  = $config_customername
							AppVersion    = $usercontextVersion;
							reglocation   = $regkeyApp
							regValue	  = 'Version'
							installCMD    = $icmd
							uninstallCMD  = $ucmd
							context	      = $context
						})
					$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-UserContext\config.csv" -NoTypeInformation
					$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\config.csv")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
							
						}
						
					}
					else
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $false
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
							
						}
					}
					
				}
				if ($bbSystemContext -like $true)
				{
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $true
									systemcontextconfig		     = $null
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
						else
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $false
									systemcontextconfig		     = $null;
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = $null;
									userbuildingblockslocation   = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
					}
					else
					{
						
						
						$systemContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksSystemContextInstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
						$systemContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
						$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the System Context Package...`r`n")
						$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
						$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
						$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
						$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
						$appname = $buildingblocks_Name_textbox4.text
						$appversion = $buildingblocks_version_textbox3.Text
						$RegisterDetectionroot = "Intune_" + $config_customername
						$systemContext_installFile = $systemContext_installFile.Replace('!!AppName!!', "$appname")
						$systemContext_installFile = $systemContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_installFile = $systemContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_installFile = $systemContext_installFile.Replace('!!version!!', $appversion)
						$systemContext_installFile | Out-File "$config_buildingblockspath\$appname\System\install.ps1" -Force
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!AppName!!', "$appname")
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!version!!', $appversion)
						$systemContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\System\uninstall.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
						#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
						[void][System.Windows.Forms.MessageBox]::Show(
							'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
							'Creating System Context Package'
						) # Casting the method to [void] suppresses the output. 
						if (!(Test-Path "$config_buildingblockspath\$appname\output-SystemContext\"))
						{
							mkdir "$config_buildingblockspath\$appname\output-SystemContext\" -Force
						}
						
						
						& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\System\" -s "$config_buildingblockspath\$appname\System\install.ps1" -o "$config_buildingblockspath\$appname\output-SystemContext\" -q
						Rename-Item -Path "$config_buildingblockspath\$appname\output-SystemContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin"
						$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						$context = 'system'
						$icmd = "powershell -executionpolicy bypass -file install.ps1"
						$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
						$regkeyRoot = "HKEY_LOCAL_MACHINE\Software\$RegisterDetectionroot\"
						$regkeyApp = "$regkeyRoot$appname"
						$IntuneWinPackageConfig = $null;
						$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
								IntuneWinFile = "$appname.intunewin"
								DisplayName   = $appname
								Publisher	  = $config_customername
								AppVersion    = $appversion;
								reglocation   = $regkeyApp
								regValue	  = 'Version'
								installCMD    = $icmd
								uninstallCMD  = $ucmd
								context	      = $context
							})
						$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-SystemContext\config.csv" -NoTypeInformation
						$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\config.csv")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $true
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
						}
						else
						{
							
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $false
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = $null
									userbuildingblockslocation = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - Standalone Package Info')
							
						}
					}
				}
				
			}
		}
	}
	
	
}

$buildingblocks_Name_textbox4_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		
	}
}

$config_buildingBlocksBrowse_button1_Click={
	#TODO: Place custom script here
	if ($config_buildingBlcoks_folderbrowsermoderndialog3.ShowDialog() -eq 'OK')
	{
		$config_buildingblocks_textbox3.Text = $config_buildingBlcoks_folderbrowsermoderndialog3.SelectedPath
	}
}

$config_install_orca_buttonInstallOrcaPowershel_Click={
	#TODO: Place custom script here
$installOrca = @'



[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
$WinSDKSetup = "C:\windows\Temp\winsdksetup.exe"
try {
Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2313119" -OutFile $WinSDKSetup -ErrorAction Stop
Write-Host "Downloaded winsdksetup.exe to $WinSDKSetup"
}
catch {
Write-Error "Failed downloading winsdksetup.exe"
}

$exeParameters = '/layout "C:\Program Files\IntunePrepTool" /q /features OptionId.MSIInstallTools /quiet /norestart'

try
{
	Start-Process -FilePath $WinSDKSetup -ArgumentList $exeParameters -Wait -NoNewWindow -ErrorAction Stop
	write-host "Installation completed of $WinSDKSetup" -ForegroundColor Green
	
	
}
catch
{
	write-host "Error executing "C:\windows\Temp\winsdksetup.exe"" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	
	
}

try
{
	$startPMSI = Start-Process msiexec.exe `
    -ArgumentList '/i', '"C:\Program Files\IntunePrepTool\Installers\Orca-x86_en-us.msi"', '/qn', '/l*v', '"C:\Windows\Temp\OrcaMSI.txt"' `
    -Wait `
    -NoNewWindow `
    -ErrorAction Stop

	write-host $startPMSI
	$msilog = get-content 'c:\windows\temp\OrcaMSI.txt'
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Install done!" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green

	}
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content 'c:\windows\temp\OrcaMSI.txt'
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
}
write-host "Cleaning temp install files now" -ForegroundColor Green
Remove-Item $WinSDKSetup -Confirm:$false
Remove-Item -Path "C:\Program Files\IntunePrepTool\Installers" -Recurse -Force -Confirm:$false
Remove-Item  "C:\Windows\Temp\OrcaMSI.txt" -Confirm:$false

'@

	
	if (!(Test-Path "c:\program files\IntunePrepTool\installOrca.ps1" -PathType Leaf))
	{
		$installOrca  | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installOrca.ps1" -Confirm:$false -Force
		$installOrca | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installOrca.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$msi_open_Orca_button1_Click={
	#TODO: Place custom script here
	if (Test-Path "C:\Program Files (x86)\Orca\Orca.exe" -Type Leaf)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		$MSINewname = $msi_openfiledialog1.FileName
		$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
		$MSINewname = $MSINewname.Replace(" ", "")
		$MSIbestand = "$config_packagefolder\$msipnaam\$msiversie\source\$MSINewname"
		Start-Process "C:\Program Files (x86)\Orca\Orca.exe" -ArgumentList $MSIbestand
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Use the Install Orca (PowerShell_ISE) button in the Start/Config menu.", 'Please install Orca first') # Casting the method to [void] suppresses the output.
		
	}
	
}

$msi_gotobuildingblocks_button2TestInstallPowershe_Click={
	#TODO: Place custom script here
	
}

$msi_buttonOptionalGoToBuilding_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msi'| Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msi' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msi_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $msi_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
	
	
}

$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile_Click= {
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msi_packagenaam_textbox1.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
		}
	}
}

$bb_gobackToPackageInProgress_button1_Click={
	#TODO: Place custom script here
	if (!(Test-Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Type Leaf))
	{
		
	}
	else
	{
		$BBWheretoGoBack = get-content 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt'
		if ($BBWheretoGoBack -like 'msi')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $true
			$package_msi_tabcontrol2.Visible = $true
			$package_msi_tabcontrol2.Dock = 'Fill'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'exe')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $true
			$package_exe_tabcontrol2.Visible = $true
			$package_exe_tabcontrol2.Dock = 'Fill'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'msix')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'Fill'
			$MSIX_tabcontrol1.Enabled = $true
			$MSIX_tabcontrol1.Visible = $true
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'choco')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $true
			$tools_chocolatey_tabcontrol1.Visible = $true
			$tools_chocolatey_tabcontrol1.Dock = 'Fill'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'winget')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $true
			$package_winget_tabcontrol2.Visible = $true
			$package_winget_tabcontrol2.Dock = 'Fill'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
	}
	
}

$bb_standalone_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_standalone_radiobutton1.Enabled -eq $true)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_standalone_radiobutton1.Enabled -eq $false)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
	}
	
}

$bb_usePackageInProgress_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $true)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
		
	}
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $false)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
	{
		if (($buildingblocks_Name_textbox4.Text -like $Null) -or ($buildingblocks_version_textbox3.Text -like $Null))
		{
			[void][System.Windows.Forms.MessageBox]::Show(
				"Please go to your MSI, MSIX, EXE, Chocolatey or Winget package. After testing install, then use the '(Optional) Go to Building Blocks' button",
				"Button '(Optional) Go to Building Blocks' not used!"
			)
		}
	}
	
	
}

$buildingblocks_add_script_buttonAddShotcut_Click={
	#TODO: Place custom script here
	
}

$exe_open_withqquestion_button1_Click={
	#TODO: Place custom script here
	[void][System.Windows.Forms.MessageBox]::Show(
		"If the EXE file supports this, a popup will open with all the install parameters. If the EXE file does not support it, it might launch the setup. In that case, please close it before continuing.",
		'Testing opening EXE file with /?'
	)
	[string]$exe_org_path = $exe_openfiledialog1.FileNames
	Unblock-File -Path $exe_org_path -Confirm:$false
	Start-Process $exe_org_path -ArgumentList '/?' -WindowStyle Normal
	
}

$exe_test_done_button1CreateInstallScript_Click={
	#TODO: Place custom script here
	$exe_preBackupPath64 = Get-Variable -Name exe_preBackupPath64 -ValueOnly -Scope Script
	$exe_preBackupPath32 = Get-Variable -Name exe_preBackupPath32 -ValueOnly -Scope Script
	$backupFolder = "$env:LOCALAPPDATA\temp"
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath64 = Join-Path $backupFolder "PostChanges64_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath32 = Join-Path $backupFolder "PostChanges32_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath32" /y | Out-Null
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath64" /y | Out-Null
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$regDiffFile64 = Join-Path $backupFolder "Difffile64_$timeStamp.reg"
	$regDiffFile32 = Join-Path $backupFolder "Difffile32_$timeStamp.reg"
	function Compare-RegFiles
	{
		param (
			[string]$OldRegPath,
			[string]$NewRegPath,
			[string]$DiffOutPath
		)
		
		$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
		$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
		$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
		$differences = New-Object System.Collections.Specialized.OrderedDictionary
		$currentKey = $null
		foreach ($line in $newLines)
		{
			if ($line -match '^\[\S+\]$')
			{
				$currentKey = $line
				continue
			}
			if ($line -match '^\S+=' -and $currentKey)
			{
				if (-not $oldHashSet.Contains($line))
				{
					if (-not $differences.Contains($currentKey))
					{
						$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
					}
					$differences[$currentKey].Add($line)
				}
			}
		}
		if ($differences.Count -gt 0)
		{
			Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
			foreach ($key in $differences.Keys)
			{
				Add-Content -Path $DiffOutPath -Value "`r`n$key"
				foreach ($val in $differences[$key])
				{
					Add-Content -Path $DiffOutPath -Value $val
				}
			}
			$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
		}
		else
		{
			if (Test-Path $DiffOutPath)
			{
				Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
			}
		}
	}
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath64 `
					 -NewRegPath $PostBackupPath64 `
					 -DiffOutPath $regDiffFile64
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath32 `
					 -NewRegPath $PostBackupPath32 `
					 -DiffOutPath $regDiffFile32
	Remove-Item $PostBackupPath64 -Confirm:$false
	Remove-Item $exe_preBackupPath64 -Confirm:$false
	Remove-Item $PostBackupPath32 -Confirm:$false
	Remove-Item $exe_preBackupPath32 -Confirm:$false
	
	foreach ($file in @($regDiffFile64, $regDiffFile32))
	{
		if (Test-Path $file -PathType Leaf)
		{
			$regString = Get-Content $file
			$regInfo = @{ }
			
			foreach ($line in $regString)
			{
				if ($line -match '^\s*\"(?<key>.+?)\"=\"(?<value>.*)\"')
				{
					$regInfo[$matches['key']] = $matches['value']
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=dword:(?<value>.+)')
				{
					$regInfo[$matches['key']] = [Convert]::ToInt32($matches['value'], 16)
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=(?<value>.+)')
				{
					$regInfo[$matches['key']] = $matches['value'].Trim().Trim('"')
				}
			}
			
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("DisplayName: " + $regInfo["DisplayName"] + "`r`n")
			$exe_output_textbox1.AppendText("DisplayVersion: " + $regInfo["DisplayVersion"] + "`r`n")
			$exe_output_textbox1.AppendText("InstallDate: " + $regInfo["InstallDate"] + "`r`n")
			$exe_output_textbox1.AppendText("UninstallString: " + $regInfo["UninstallString"] + "`r`n")
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace ("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
					}
				}
			}
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text  }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
						 }
				}
			}
			
		}
	}
	
	
}

$tablelayoutpanel3_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_buttonOpenReleaseNotesOnIn_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/updates/intunepreptool-release-notes-1-6-6-0/'
}


$exe_gotobuildingblocksButton_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $exe_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $exe_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$tools_choco_gotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $tools_choco_displayname_textbox3.text
	$buildingblocks_version_textbox3.text = $tools_choco_appversion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$msix_GotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msix_packagename_textbox3.text
	$buildingblocks_version_textbox3.text = $msix_packageVersion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$winget_gotobuildingBlocks_buttonTestInstallPowershel_Click={
	#TODO: Place custom script here
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $winget_displayname_textbox1.text
	$buildingblocks_version_textbox3.text = $versie_textbox2.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$exe_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $exe_packagenaam_textbox1.text
			$PacVersion = $exe_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msix_packageVersion_textbox3.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$tools_choco_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $tools_choco_displayname_textbox3.text
			$PacVersion = $tools_choco_appversion_textbox3.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $winget_displayname_textbox1.text
			$PacVersion = $versie_textbox2.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$upload_LoadBuildingBlocksg_button1_Click={
	#TODO: Place custom script here
	$upload2_IntuneWinFile_textbox1.Text = $null;
	$upload2_DisplayName_textbox2.Text = $null;
	$upload2_Publisher_textbox1.Text = $null;
	$upload2_AppVersion_textbox1.Text = $null;
	$upload2_reglocation_textbox2.Text = $null;
	$upload2_regValue_textbox1.Text = $null;
	$upload2_installCMD_textbox1.Text = $null;
	$upload2_uninstallCMD_textbox1.Text = $null;
	$upload2_context_textbox1.Text = $null;
	
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_configLoaded_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_checkboxSetupAssignmentLikeP.Enabled = $false
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		$systemcsvLOC = $BuildingBlocksCSVContent.systemcontextconfig
		$usercsvLOC = $BuildingBlocksCSVContent.usercontextconfig
		if (($BuildingBlocksCSVContent.usercontext -like $true) -and ($BuildingBlocksCSVContent.systemcontext -like $true))
		{
			$upload_panel2.Enabled = $true
			$upload_panel2.Visible = $true
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $systemcsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $systemcsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $usercsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $usercsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload2_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload2_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload2_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload2_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload2_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload2_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload2_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload2_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload2_context_textbox1.Text = $context
	
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
			
		}
		else
		{
			
			if ($systemcsvLOC -like $null)
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $usercsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $usercsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
			else
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $systemcsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $systemcsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
		
		}
		
		
	}
	
	
	
}

$config_howtoBasicSetup_buttonOpenHowToBasicSetupO_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/basic-setup/'
}

$BB_OpenHowTo_button_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/building-blocks/'
}

$tools_choco_label5_Click={
	#TODO: Place custom script here
	
}
]]></Code>
  <TV>0</TV>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="False">1775</Line>
    <Line Disabled="False">12098</Line>
    <Line Disabled="False">14562</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>0</Mode>
  <Assemblies />
</File>