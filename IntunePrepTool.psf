<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>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
6UHrmmFyvpxZLufPlO/dLH+J62UIeFOSpIe2gyMLcfJ09QvrtdZV92+OTMarh8Zjz8HjrY/9p86+
2do7Xt7UqwHgyPjp8n03Wq8PTa/Fbw6fiN6hmdbXapCoXp8+dz2Gy8Cw98hMjMycb71HT69eL9+7
XH7Tn4kDowuxf3A6TqxsltffbP1v/IdGl8p75+VY2Hg7Zs9c2tkAcOmdiPkLb8Vi+aaFy/+91aUP
YvHy72Pp0nuxuP522XunPN+KpYvl68VbsVw9l5YvvdtqqfyQam9rvbW3dPG35ft+u/VcWtl8LybL
kDC1+tbWmdb59p/1h+rvlSTpYW25vPcdPVF+wZ04E4Mnz8XQybUYm7u41fzF8uZ9IQYmV1t7h4+v
xNDUWnkT3zpbvT48fb51rj5f7VevVz+nOj9cvr+vfK3Pj8ysx+jcRutr9T3164OlQ2OnWoNA9R66
sHplZwPA5Xej/EXejvnzN2LhPre4fjMWy7DRaU+SpEepxQs3Yn7tepxYvnTHJstv50vrb8Xs6rWY
WLrY8UzdRGnqzJVY2rgZU6evdDzTbPrs1dZ77Mrm+7F47urOBoAr70VU/yvgD1/4cTz51FPxj08/
fbtnblc/168395rrbmfr5+a629lOe/W621697rbX/lqnvQdxtv315l5zvZO95rr9bPvznfbbn9vX
7fvNvYftbP3cXHc7222vub/d892erdft+829butue+2vddrrtt7JXnPd6Wy93u75fp6t1+37zb1u
6257D/Js/Xpzr7nffL6fZ+t1p/325+3W3fY+7tn69eZec91tr15v9/yHnn7mW/FMqfra6fmZb219
bZ0tVettz7atq39W/dzcb3/+xje/Gc8++2xcuPJWnL76+7sbAFYuvxvf/va/xl//1V/G41/8Yjz+
+OPxxO3q5+prXftec93tbP3cXHc722mvXnfbq9fd9tpf67T3IM62v97ca653stdct59tf77Tfvtz
+7p9v7n3sJ2tn5vrbme77TX3t3u+27P1un2/uddt3W2v/bVOe93WO9lrrjudrdfbPd/Ps/W6fb+5
123dbe9Bnq1fb+4195vP9/Nsve603/683brb3sc9W7/e3Guuu+3V6+2e7+fZet1tv/35sc9/Pp56
8mtx9eZ7sXLlg7sfAL7z3e+VH3T7zf+JJyRJ0iPQY489Fl9/6sm48ta79z4APFEGgOqHfelLX5Ik
SY9AX/jCF+IbX7/HAeDUpVsGAEmSHsEMAJIkJexjDQCuACRJejQzAEiSlDBXAJIkJcwAIElSwlwB
SJKUMJ8ASJKUMAOAJEkJcwUgSVLCDACSJCXMFYAkSQkzAEiSlDBXAJIkJcwAIElSwlwBSJKUMAOA
JEkJcwUgSVLCfAIgSVLCDACSJCXMFYAkSQkzAEiSlDBXAJIkJcwAIElSwlwBSJKUMAOAJEkJcwUg
SVLCDACSJCXMFYAkSQnzCYAkSQkzAEiSlDBXAJIkJcwAIElSwlwBSJKUMAOAJEkJcwUgSVLCDACS
JCXMFYAkSQkzAEiSlDBXAJIkJcwnAJIkJcwAIElSwgwAkiQlzH8DIElSwnwCIElSwgwAkiQlzBWA
JEkJMwBIkpQwVwCSJCXMACBJUsJcAUiSlDCfAEiSlDADgCRJCXMFIElSwgwAkiQlzBWAJEkJMwBI
kpQwVwCSJCXMACBJUsJcAUiSlDADgCRJCXMFIElSwnwCIElSwgwAkiQlzBWAJEkJMwBIkpQwVwCS
JCXMACBJUsJcAUiSlDADgCRJCXMFIElSwgwAkiQlzBWAJEkJ8wmAJEkJMwBIkpQwVwCSJCXMACBJ
UsJcAUiSlDADgCRJCXMFIElSwgwAkiQlzBWAJEkJMwBIkpQwVwCSJCXMJwCSJCXMACBJUsJcAUiS
lDADgCRJCXMFIElSwgwAkiQlzBWAJEkJMwBIkpQwVwCSJCXMACBJUsJcAUiSlDCfAEiSlDADgCRJ
CXMFIElSwgwAkiQlzAAgSVLC/DcAkiQlzCcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsJ8AiBJ
UsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJ
CfMJgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCTMASJKU
MFcAkiQlzCcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQl
zAAgSVLCXAFIkpQwnwBIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLC
XAFIkpQwA4AkSQlzBSBJUsJ8AiBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQw
A4AkSQlzBSBJUsIMAJIkJcwVgCRJCfMJgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlz
BSBJUsIMAJIkJcwVgCRJCTMASJKUMFcAkiQlzCcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIM
AJIkJcwVgCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwnwBIkpQwA4AkSQlzBSBJUsIMAJIkJcwV
gCRJCTMASJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsJ8AiBJUsIMAJIkJcwVgCRJCTMA
SJKUMFcAkiQlzAAgSVLCXAFIkpQwA4AkSQlzBSBJUsIMAJIkJcwVgCRJCfMJgCRJCTMASJKUMFcA
kiQlzAAgSVLCXAFIkpSwj/0JwLf/5Tvx2GOfb/0gSZL0aPS5z30uvvbVr9zbALB88Z344a5d8eTX
/j6eevIfPuzrT330uX3dvt/ce1Bn29c72WuuO52t19s938+z9bp9v7nXbd1t70GerV9v7jX3m8/3
82y9bt9v7nVbd9v7uGfr15t7zfVOzm73fD/P1utu+82zO93rdLZ+vbnXXN/t2e326vV2z5/k2Xrd
6dx26zvtNb/Wz9ud7bTXXH/SZzs91+tuZ+t1/dxc38vZ+rVOe/d6tv315l5zfS9nv/qVv4sfPPf9
uHq3A8DmuxELF27G2qXrZXq41Zogtr52em5ft+839x7U2fb1Tvaa605n6/V2z/fzbL1u32/udVt3
23uQZ+vXm3vN/ebz/Txbr9v3m3vd1t32Pu7Z+vXmXnO9k7PbPd/Ps/W6237z7E73Op2tX2/uNdd3
e3a7vXq93fMnebZedzq33fpOe82v9fN2ZzvtNdef9NlOz/W629l6XT831/dytn6t0969nm1/vbnX
XN/L2fL1xq1Yv/ZunLr8/s4GgF0vvNhz7YOIlc334/TVD1qTgyRJesTa/F15838vzr75P3Fq/cad
B4DvfPf7+y/ffD+W1q5JkqRHvJWNm7FweuPOAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwKPvUp/4PX+MLY6j4rE8AAAAASUVORK5CYII=</Preview>
  <Form>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</Form>
  <Code><![CDATA[class config_customerinfo {
	[string]$customername
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
	
	
}
function PowershellISEOnTop {
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}	
}



$tools_winget_label_Load = {
	Set-ControlTheme $tools_winget_label -Theme Dark
	
	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv= Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($winget_exe.count -gt 1)
		{
			$winget_exe = $winget_exe[-1].Path
			& $winget_exe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
		}
		
		if (!$winget_exe)
		{
			
			[void][System.Windows.Forms.MessageBox]::Show('Winget expected in C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\ ', 'Winget missing') # Casting the method to [void] suppresses the output.  }
			
		}
		else
		{
			if (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			}
		
		}
		
		
		
	}
	$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
	if ($restrictionpolicy -ne 'Unrestricted')
	{
		
		if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		{
			$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
			if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
			{
				powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
			else
			{
				$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
				Start-Sleep 1
				powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
		}
		
		
		try
	{
		
		Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
	}
	catch
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	}
	
	$problemPSModule = $null;;
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if ($problemPSModule -eq 1)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	try
	{
		
		Get-ChildItem -Path "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -ErrorAction Stop
	}
	catch
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: Download Winget MSIX bundle', 'Winget MSIX bundle missing') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	
	
	
	refreshTenants
	#>
	$config_tabpage.Dock = 'Fill'
	$config_tabpage.Visible = $true
	$config_tabpage.Enabled = $true
	
	
	
	
}


$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $tools_winget_label -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $tools_winget_label -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$versie = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$wingetID\$versie\source" -s "$outputDirectory\$wingetID\$versie\source\install.ps1" -o "$outputDirectory\$wingetID\$versie\output" -q
	
	Rename-Item -Path "$outputDirectory\$wingetID\$versie\output\install.intunewin" -NewName "$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Versie `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Versie `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$wingetID.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $versie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$wingetID\$versie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$wingetID\$versie\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$winget_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {

	$wgid = $winget_WingetID_textbox1.text

	
		$showurl = winget show $wgid --accept-source-agreements
		foreach ($l in $showurl)
		{
			if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
		}
		
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text

	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	
	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
		})



$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			if ($config_customerinfo.customername -eq $cis.customername)
			{
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			}
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
		
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else {
		
		if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
		{
			
			New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
		{
			
			New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
		}
		$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
		$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
		$exe_output_textbox1.AppendText("`r`n")
		$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
		
		[string]$exe_org_path = $exe_openfiledialog1.FileNames
		try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false 
			Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
			$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
			$exe_panel1.Enabled = $true
			$exe_panel1.Visible = $true
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
		}
		$exe_open_sourcedir_button1.Enabled = $true
		$exe_open_sourcedir_button1.Visible = $true
		}
	}
		
		
	}
	
	$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true


	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	

}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true

	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")
	$exe_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$exe_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				 
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			 #$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:53
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
	write-host $startPMSI
	$msilog = get-content $logfileMSI
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Script started i.cmd" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
		write-host ""
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green

	}
	
	if ($msiuninstallcode -eq $null) { $excode = 1 ; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
    Else
    {
        write-host "Script started i.cmd" -ForegroundColor Green
        write-host "Possible uninstall command is:" -ForegroundColor Green
        write-host ""
        write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
        write-host ""
        Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
        write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
        $excode = 0
    }
   
	
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content $logfileMSI 
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue


    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	#$msi_installFile = $msi_installFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true
	$msi_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msi_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
	
			$config_csv_openfiledialog1.ShowDialog()
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			$upload_DisplayName_textbox1.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox1.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
		if (!(test-path "$filepath\Logo.png" -PathType Leaf))
		{
			[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
			$upload_logo_button2.Enabled = $true
			$upload_logo_button2.Visible = $true
			
		}
		
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2022 v5.8.210
	 Created on:   	26/02/2023 14:05
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
	.DESCRIPTION
		Params are used from IntunePrepTool
		Uses Powershell modules MSAL.PS from Jason Thompson and IntuneWin32App from Nickolaj Andersen
		
#>

#Requires -RunAsAdministrator
#Installatie Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
}

[string]$config_csv_path = '!!CONFIGCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain') {
		$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
		$tenantID = $checkCredLoad.TargetName
		$tenantID = $tenantID.Split("_")[1]
		$AppId = $checkCredLoad.UserName
		$Secret = $checkCredLoad.Password
		}
		else {
		$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
		$tenantID = $cust.tenantID
		$AppId = $cust.appId
		$Secret = $cust.clientsecret

		}
	}
}

Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
$logoaanwezig = get-childitem "$filepath\logo.png"
if ($logoaanwezig -eq $null) { write-host "No Logo.PNG found in Output Directory" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
else
{
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
	write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam -Verbose
	if ($Win32AppEvtVorigeVersies -ne $null)
	{
		write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
		write-host $evtvversie
		$alversieAppAanwezig = $true;
		write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	}
	
	else
	{
		$alversieAppAanwezig = $false;
	}
	
	write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	 if ($logoaanwezig -eq $null) { 
        $Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -InstallExperience "system" -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose }
    else
    {
	$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience "system" -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose
    }
	Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	
	if ($SetupLikeOldVersion -eq $true)
	{
   <#
	
	$response = read-host "Press q to do nothing, Any other key for setting up dependencies. Dependency will be the same if older version. (When exists)"
	$niksdoen = $response -eq "q"
	if ($niksdoen -eq $true) { write-host "Ok.. We won't do this" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		if ($dep -notlike $null)
		{
			$dependency = Get-IntuneWin32App | Where-Object { $_.Displayname -like $dep }
			$dep2 = New-IntuneWin32AppDependency -DependencyType AutoInstall -ID $dependency.Id
			Add-IntuneWin32AppDependency -ID $Win32App.Id -Dependency $dep2 -Confirm:$false
			write-host "Dependency done"; Write-host "`r`n"; Write-host "`r`n";
		}
		else { write-host "No dependency found in older version" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	}
#>
		
		if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
		else
		{
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
				$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
				$evtvversie = $vorigeversie.DisplayVersion
				
				if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host ""; Write-host "`r`n"; Write-host "`r`n"
					$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
					$niksdoen = $response -eq "q"
					if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
					else
					{
						write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
						Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
						try
						{
							Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
						}
						catch
						{
							Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
						}
					}
				}
			}
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Write-host "We will fix superseedence for:" -ForegroundColor Green
					$vorigeversie.displayVersion
					
					$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
					$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
					if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
					Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
				}
			}
			
			
			
		}
		
		
	}
	if ($AvailableAllUsers -eq $true)
	{
		
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll -Verbose
		
	}
	
	
	if ($RequiredAllDevices -eq $true)
	{
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll -Verbose
		
		
		
		
	}
	



'@
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	
	$depWin = $upload_dep_textbox1.Text
	$tenantName = $upload_upload_listbox1.SelectedItem
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
	if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
	}
	if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
	}
	if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
	}
	
	
	
	
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$uploadIntuneFile | Out-File $filepath\uploadIntune.ps1 -Force
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE?; After uploading: Please reopen IntunePrepTool to create another package ', 'Upload to Intune', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		powershell_ise -file $filepath\uploadIntune.ps1
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$fid = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$fid\$wid\$vid\Output\logo.png" -ErrorAction Stop
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
	
	
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msi_output_textbox1.AppendText("`r`n")
	$msi_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]
		$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]
		$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]
		$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Item,
	    [Parameter(Mandatory=$false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
	-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param(
	$InputObject, 
	[ValidateNotNull()]
	[System.Data.DataTable]$Table,
	[switch]$RetainColumns,
	[switch]$FilterCIMProperties)
	
	if($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @(,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;		
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					tenanturl	    = $cis.tenanturl;
				})
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$vid = $versie_textbox2.Text
		if ($vid -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			
			
			$wid = $winget_WingetID_textbox1.text
			
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			
			
			$WinGetID = $wid
			$regApp1 = $DisplayName
			$versie = $vid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\output"
			}
			if ($winget_install_winget_checkbox1.Checked -eq $true)
			{
				$includeWingetRequirment = $true
				Copy-Item "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" "$outputDirectory\$wingetID\$versie\source\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -Force
				
			}
			else
			{
				$includeWingetRequirment = $false
			}
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	18-5-2024 03:27
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$versie.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
if ($includeWingetRequirment -eq $true)
{
        Add-ProvisionedAppxPackage -online -PackagePath ".\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -SkipLicense -ErrorAction SilentlyContinue
		Start-Sleep 5
		$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($ResolveWingetPath)
		{
			$WingetPath = $ResolveWingetPath[-1].Path
		}
		$wingetexe = $ResolveWingetPath
		
		if (Test-path $wingetexe)
		{
			Write-host "Installation Winget success."
		}
		else
		{
			Write-Host "Installation Winget Failed."
		}
	
	
}

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>




$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

if (!$winget_exe) { Write-Error "Winget not installed" $excode = 1 }
else { $excode = 0 }

try
{
	
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine

		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget

		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		}
	}
	else
	{
		& $winget_exe uninstall --id $WinGetID -h
	}
	
	
}
catch
{	
}
if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
}
#### Place extra actions here:




<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!versie!!', $versie)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$wingetID\$versie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
		}
	}
	
}

$winget_test_install_button1_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$winget_uninstall_test_button_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$winget_show_version_button1_Click={
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click={
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);

	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
				
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
		
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
		
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			  
			
			
			
			
			
			
		}
		
	}
	
	

	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click={
	#TODO: Place custom script here
	if ( $config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click={
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged={
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click={
	#TODO: Place custom script here
	$upload_logo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $upload_logo_openfiledialog1.FileNames
	
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	
	$itwnf = $ConfigCSVImport.IntuneWinFile
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$filepath\logo.png"
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
}

$timer1_Tick={
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click={
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$hover_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged={
	#TODO: Place custom script here
	$hover_textbox1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile| Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'

	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}




$Weblink_intunewin_tabpage6_Click={
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged={
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged={
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click={
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
			
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
			
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile )
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
	
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
	
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click={
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click={
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
			
			
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click={
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click={
	#TODO: Place custom script here

	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	05/13/2024
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the creation of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
					
					if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
					}
					
					if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
						
						if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
							$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
							
							$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
							if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
							{
								$WeeklyTaskAMPM = "AM"
							}
							else
							{
								$WeeklyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
							
						}
						if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
							
							
							$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
							if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
							{
								$DailyTaskAMPM = "AM"
							}
							else
							{
								$DailyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
							
							
							
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
							
						}
						
						
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
					}
					
				
					$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
					$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
					
				}
				
				
			}
			
			
			
			
		}
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
					if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
						
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
					}
					if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
						if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
							$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
							
							$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
							if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
							{
								$WeeklyTaskAMPM = "AM"
							}
							else
							{
								$WeeklyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
							
						}
						if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
							
							
							$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
							if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
							{
								$DailyTaskAMPM = "AM"
							}
							else
							{
								$DailyTaskAMPM = "PM"
							}
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
							
							
							
						}
						else
						{
							$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
							
						}
						
					}
					else
					{
						$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
					}
					
					$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
					$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
					$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
					$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
					
					
					
				}
				
			}
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click={
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>


#Nuget installation
$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
$nugetInstallPath = "$env:ProgramFiles\NuGet"
if (-not (Test-Path -Path $nugetInstallPath))
{
	New-Item -ItemType Directory -Path $nugetInstallPath -Force
}
$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
if (Test-Path -Path $nugetExePath)
{
	Write-Host "NuGet has been installed successfully at $nugetExePath"
}
else
{
	Write-Host "NuGet installation failed"
}
$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
if ($path -notlike "*$nugetInstallPath*")
{
	[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
	Write-Host "NuGet has been added to the system PATH"
}
else
{
	Write-Host "NuGet is already in the system PATH"
}
& $nugetExePath | Select-String "NuGet Version"


Get-PackageProvider -Name Nuget -Force

#Installation Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Write-Host "IntuneWin32App 1.4.4 already installed"
	}
	else
	{
		Write-Host "Required Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Authentication 2.18.0 already installed"
	}
	else
	{
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Applications 2.18.0 already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		Write-Host "CredentialManager 2.0.0 Powershell module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Identity.SignIns 2.18.0 Powershell Module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click={
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click={
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click={
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click={
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	

	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget| Select Name,ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 

}

$download_winget_listbox1_SelectedIndexChanged={
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged={
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click={
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click={
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click={
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click={
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
	
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
	
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	try
	{
		$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nUbinstall.ps1 NIET created `r`n")
	}
	}
}

$exe_radiobutton3_CheckedChanged={
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged={
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click={
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken } 
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click={
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $powershell_package_name_textbox1.text
	$exeversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$exepnaam\$exeversie\output\config.csv file there", 'Upload Now?',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
	
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click={
	#TODO: Place custom script here
$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$button1_Click={
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
	
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click={
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$addTenantToolStripMenuItem_Click={
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click={
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click={
	#TODO: Place custom script here

	$tenantName = $config_tenant_name_textbox3.Text
	$appRegName = $config_tenant_appRegName_textbox3.Text
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		if ($config_add_Tenant_radiobutton1.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppReg.exe" -appRegName $appRegName -customername $tenantName
		}
		if ($config_add_Tenant_radiobutton2.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe" -appRegName $appRegName -customername $tenantName
		}
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click={
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible= $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click={
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click={
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click={
	

	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click={
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click={
	#TODO: Place custom script here
	Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click={
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
		
}

$MSIX_CreateScripts_button2_Click= {
	
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam )
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
   #$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
			
	
}

$msix_opensource_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_test_uninstall_button_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
			Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_create_uninstall_Script_button2_Click={
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName )
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click={
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	$msix_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$MSIX_UploadLogo_button_Click={
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$msixpnaam\$msixversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$powershell_open_install_ps_button2_Click={
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click={
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text

	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click={
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		
		
		$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
		
		$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text 
		$fid = $config_packagefolder; $outputDirectory = $fid
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
		Unblock-File -Path $powershell_install_org_path -Confirm:$false
		$powershellInputInstall = Get-Content -Path $powershell_install_org_path
		$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
		$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
		$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
		$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
		$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
		foreach ($line in $powershelll_installFile)
		{
			if ($line -like "#PowershellInstallStart*")
			{
				
					foreach ($inputLine in $powershellInputInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
			
			
		}
		
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\IntunePrepTool_msgfile.dll" -Confirm:$false
		
		
		
	
		
		
		[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
		Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
		$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
		$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
		$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
		foreach ($line in $powershell_uninstallFile)
		{
			if ($line -like '#PowershellUninstallStart*')
			{
				
				foreach ($inputLine in $powershellInputUNInstall)
				{
					$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
			}
			else
			{
				$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
			}
			
			
		}
		$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
		$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$Powershell_testUnInstall_button2.Enabled = $true
		$Powershell_testUnInstall_button2.Visible = $true
		$Powershell_testInstall_button2.Enabled = $true
		$Powershell_testInstall_button2.Visible = $true
		$Powershell_CreateIntuneWIn_button2.Enabled = $true
		$Powershell_CreateIntuneWIn_button2.Visible = $true
		
	}
}

$powershell_opensource_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click={
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click={
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test install?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_testUnInstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstall?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_CreateIntuneWIn_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$msipnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$powershell_output_textbox5.AppendText("un-install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$powershellpnaam"
	$regkeyApp
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Versie' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("When needed upload Logo to upload *.png file. `r`n")
	$powershell_output_textbox5.AppendText("Then use this config.csv in the upload tab to upload package to Intune. `r`n")
}

$Powershell_upload_logo_button_Click={
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$powershellpnaam\$powershellversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
	$powershell_output_textbox5.AppendText("`r`n")
	$powershell_output_textbox5.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$updatepackage_msi_open_config_button1_Click={
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click={
	#TODO: Place custom script here
	
}

$labelAppName_Click={
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click= {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
		if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
	try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot 
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool'| Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot ="Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click={
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}


$powershell_generateNEWPS_ps_button2_Click={
	#TODO: Place custom script here
	
}

$powershell_open_install_ps_button2_Click={
	#TODO: Place custom script here
	
}

$powershell_open_uninstall_ps_button2_Click={
	#TODO: Place custom script here
	
}

$powershell_create_packageDIR_button2_Click={
	#TODO: Place custom script here
	
}

$MSIX_TIP_button2_Click={
	#TODO: Place custom script here
	
}

$MSIX_UploadLogo_button_Click={
	#TODO: Place custom script here
	
}

$MSIX_Create_Package_Click={
	#TODO: Place custom script here
	
}

$exe_open_Azure_OpenAI_Example_button1_Click={
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click={
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
	
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key = $config_openAI_textbox6.Text
			endpointURL  = $config_openAI_textbox7.Text
			deploymentName	= $config_openAI_textbox8.Text
		
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}

$config_openAI_textbox6_TextChanged={
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged={
	#TODO: Place custom script here
	
}

$config_openAI_textbox8_TextChanged={
	#TODO: Place custom script here
	
}

$config_openAI_help_Click={
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"
}



]]></Code>
  <TV>0</TV>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="True">758</Line>
    <Line Disabled="True">1615</Line>
    <Line Disabled="False">2119</Line>
    <Line Disabled="False">3735</Line>
    <Line Disabled="False">5324</Line>
    <Line Disabled="True">6498</Line>
    <Line Disabled="True">6500</Line>
    <Line Disabled="True">6606</Line>
    <Line Disabled="False">7689</Line>
    <Line Disabled="True">10241</Line>
    <Line Disabled="True">11341</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>0</Mode>
  <Assemblies>
    <Assembly>Renci.SshNet, Version=2016.0.0.0, Culture=neutral, PublicKeyToken=1cee9f8bde3db106|C:\Users\rink\Desktop\ex-desktop\Renci.SshNet.dll</Assembly>
  </Assemblies>
</File>