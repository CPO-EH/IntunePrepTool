<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAAAXNSR0IArs4c6QAAAARnQU1BAACx
jwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAFcLSURBVHhe7b1nVxxJ2q67f8tZ51ecL2etfT7s
82XvMzN73nFvj39npu20m2nfMi3vvUEIgRBICCOER4CQBAIEwnvvvUcC5Ps+8WRRUkGXLBJIquti
XSsrk8isrKysiCcyIiP/GwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAvIX883/8j/83Lux4dNyRY5Fxh8MiEBER8Q3UyvJ9B4/E/Z//5/8Rt1DGP57//t//
n/TLZQ2q77uh2u5J1XQhIiLim6iV402DszoZl6yFYv7xHI88Fdc0cFOXqzp0xbMTERERn0tXflZ3
qrC2+5ksqOkKujyYz5PW9qGgpkfVbUNPDwCORUTHNfXf8Fa8Wmtv0qeCuiEV1g/pasOwrtb1ecuv
ev9/VnuCLAuw7in/R0REfMMsdAV1RkGt0i5VK+3yY3T/S79co0vlbYvSZhbWK+tqg2dmQZ1vuTPj
iktb0e6m/rQ1ynJpfenr3TYepU13aQuqu1RU36eKpt6nBwBhx6Pimgdn3Qq9zn6V1beosvqayq4X
6FpZgYqr6lXcMKBi9/9it1GzpHFAJQ322pY5A17b8iIXMBS5Qv5hmoWp9786O0id7mB1PVrPP0VE
RHwDvdbYr4tlra4grvIK94tlLcq/3qp899rTvfYvy3YFd9KF664gr/PS2rJzF64pMatYCZlXlZpf
4daxdS1tnUtbvpC2VXmlzUp2aROySlzaIqVfqvS9jzPdBQG515pV1jKkyua+ZwsA2kZuuZ13hXzz
lNqK9utmxXp1Zb+n0rD/S9eKslTaMqaLJXVeQX2tsU+Xy+pdId6t0qYBz5J6V9i7D1/WNKjShm5l
XypWxuXrrrC39P2eXjq3fkldp9Iv5OtCUZ1br1dlzUPetLimTbnFdd68f7uIiIhvgtddoXupvN2V
bQ3eVW4rIy9ed7V8V3BnuNp6vvufLTMvucI6ObdCF0tbXPDQr+ziRqVm5Csnr0BXCkqUmHpRl6vs
qkKv8l1QkZxb6QUPdnU9160TczZduRevKi0jTzHn8tz79XrbzXHbsSCkon1E1a0Dz9YE0DVxV+Vt
IypvH1dH9vsaufq9mvO3KPfA/63rDW3exi4WlbuCvURZV0qVeuGKLhRUqqC8WfnFFcq8WKScq5Xu
/0XKcK+znBcKy12a68opKFOapS900U5+sQqq3UEor3P/K1eOW5ZXVOnSXFduYakXAFR2jquibRgR
EfGNsapjVIXVXcotafKukl+u7NLpxEzlu3LxYn6he52tQlegl7gC/0pFh1Lyq1wg0OaChyFdKG5W
ekauTkSdVWJiqs6n56ugxq6au+24tKn51brsAgiraNvl/YjYFFWWVygt/YLi0gu9bZQ09CvPBQdX
KjtU0z2h2vZn7APQO/VAVV3Tqm5qUvuFz1zhv02VKV/ocvxXbkNTqu4c0eVrlcovrXOFfr1XeF8q
rdEF98GyXG3/SnmTrpRWKyOvULlWoF+57gKKYVfQ1+tKWY0y8ktcAV/mBQpXazpUXN2kC1fKXOFf
5SxX7lUXCRW7bZY1q6bH3m8MERHxjbHWFbpFroC/WNqq660jXpP6meRcpWVdcrX7izqbkq9rrqAu
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
S+t1YnB/oy5DHp2Yces/8Dp3BX5A24alNbz38F4tvI9L721rQVv/wYNH+2T499Fbx62/6OB4+j6H
bdvPwzUerms80GBfr2Zmby3M2zFYui2ftp7fpSxd7s3bnzd99P8HQbZ7/17Atn2rezxc5lwWbv3A
4xloII/e59H7BaYN3J+HKey7vXt/YebJLFp/weWx3PUBAN5MJmZmnz8AKGvs1cnoaBUVXdWVK1c8
CwoKHrp0WbA0z2pxcYlKiouD/m85FhYWLjLYsufx2rVSt69Fz7Sdl5VmOV69etVz6XywZS8zTeD/
H1nkjl1xkOUv36Kioif6LGlW0jdxn4Np3+9qWlLi8pEFly4Llm45afzzK5Em2LLHza+W165de+jS
edP20fK7QP15h7l02YumeZy2D6WlpT/Zrzdd+0yP0/v/tRINjIyrbeTO8wUAtR2j+ubrb/Tb3/5W
77zzDiIi4iL/8z//8yfzgcv883/4wx/00UcfrYoffvih9/7+ffH7uH0OtuxVpfHPv2iaJ/mb3/xG
f/7zn9TS0a2uiQfPFwDUtI/o+++/11/+/Gf99a9/1V/+8pdV1/bjRf2v//ovbxpsuyvt0n0Lpu2v
nbS//vWvvS9yNbT3/t3vfufti//4Pa/+9eyz2In7+9///pXp337g+yK+zQbLX161wfbjSVoecvjw
Ya+fhnUqtmZeayq0Pja+vk0BfY7cvPUdsr5ngf+z1954Jm6dW3fueNPHr+sbJ8Saoa0NfHpqSv/+
97+9PCjY/r2t/tmV3e+//55aO3vUOX7/+QOANWvWeAHAn/70J29jq6ntg30of2H0Igbb7moYbN+W
+sc//lHr169XQkKCzp49+xPj4uKeqKWxdRMS4oP+P9DHbc/WP378uLc/yz32X375pXc+WVD5qrTt
f/PNN/r73/++7P3Ft89ghdlK+KrORdv2auTN9r7B9udx2lXk6OhoX4P0jw9UdiVXcfHnNTF7x7ds
CQ9u31BH18DC3CNuTo5qcHRK3U2N6h6eWli6mNmpYXX2dKmqvFLNLa1qa/dt5yuX/1gAEGz/Hqd9
bxa8BKscvWqtBh9sn55H+65ePADo8F0B+MMffq+MjAx1d3erta1d/QMD6u/rVWtrq1qcNn2SLe5L
6OzsVJt73bEwDfx/W9vi+WB2dXUpPz/f+0Je9MdktUM7CW1b1qu/o6NTXd1d3r51dLQv7GfHwvv5
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
7OpVS+8+p9sn73O4eZsODg5r167d3nENtp9+7XNcuJDrPexmyH02+3wrqXVwaW5pV62Lor/77nsX
DNq99sH39Ul+7T7n9u071NvX7457vi86X/jeFkftvlqB/7v1f9c/iewX0vjn/Wn82nyTi57tHuDm
5hYXvNotm20+F17b7axWA7RbpawmbD/yZ7kzw+/SzPhN0O7ksKkVHDassNU4Jgc7lZN5VbVlpUpL
uaimtlplZOap1tWQB0ZH1VRTrf6RKVUUZij2XJ63jhUAVoju2bPXK7ysjfJ193e/e3QFwC4H20PG
7KFdVrt75OL5n6b56Tq+NI/mg6WxwN+umoSFHVWkq6xYhcVvZGSkV3mxy+Px8fELhandqmY16idr
VzvtMdqWP9iVm9ra2oXfgjXJVqumpsbTXvt/FzUujS17mObhvKWp8l77tuObt6nN+7fj126Bbmho
cMHjHe3YsUM///nP9Y47rx7nz372M4WHh3vH37CKQJk75+z269ZWuy3Rd8uh79ZEm7dbD323HNr/
fLdgt6q93b/sURpbZq8Xp/Ftx26RtNvH7QrAJ598rF/96ldB9y+Ylvaf//yn9x3aFfDGxgY1e1Mr
Cxu8abMrpL3/uXlbZq99aQPSBMwHS9Pkbcctc1NbVldX5zV3W5qXGgA8bxNARfOA9u8/oIgTkd6T
07q7e9zJNqWpqRnndMDUr80HW7Z0/kXSBC53upqpp3s9PXNDI6NjXgFjTwwMPx6hqJPRP9GWW8Ex
Pj7p3ZZ44+as+3L92khT5tJlS+eftsw3b9Gt7ZP31D/3fvaEPytUG5taXM11QAmJSd5xDbaffsPD
j6u07Lrvs/s/7wpqkXpv74D7MXUoKuqkIp3B9vNp2h0KZ8/Guyh8WNPTNlKXq0nMznnOBrh02ctO
Y9+F1Qzstk/7TsYnJtQ/MOz94KyG8CzNMn7/8pe/ev1R/vGPf7wRWqGy/8AhnU9J05m4eJW7gLmr
23pJN7kgtUxVFRVKOJukc2lpyszOU2paqrJc8JkUG6fUzItKOZegzPwSt06f13/D1s3JvehtKyHx
3GvvmTPxunjxkqsVjrlpvssHqlylodKb+l/bVZEKFwxawWdBYXm5m3fLvXkvjc1XeP+zZfa/RWkq
H5em3CtE7d57f2HWvFBY2TK7h9/OQQsULl8p0KlTsYo7m/BU7Ta39Iwsl58Mqrqmwe27BdD1r9zK
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
sz/zs6nN23LfvCvQ3Xxgmtpaf5qfrhMsjfc+C8vtVpsvvvi3lxFbYfI4vSaLi74mi5kbdjuOtb+t
nPae1lZlt9u9845dzv9d0P18mjZug11+sx+B/wqSaZcDrT3e+kj4lw3bMqd/2aM0vitGXho3b2n8
80G3s2SdpWlsavP22i4PWi0nlAIA66hmtQwrnKwQslr982qZ1vNq54D9Puz7eN4a2XJ8UgBg+2UZ
r2HZ9I9353Q5PUWxSZmauDn/k8zb7uk2CvMydM1VJjLTz6vgSoHS0i6o4nqVeoZ8I5f6M36r8fuZ
nb+liaEeVdW1evPNtdXqHbnhan893nn4ogGA9SV4VVgAYIGM/UYsqPGaLVwt3potLADYtnWrfvGL
n3v7/ThtXy0f+PnPf+b1xVoN7SqQLx97Nu138tGHH3pXbZ7E0GCPeru7XGDbqI6WNo1N+wauW4qN
CTA+NqrG2iolJyaqqbPPOz8qKyuUlJTo/S7sWNtdahY0W1mxugHAwkBA9gAF/wAqb7J2AthTlizz
sbYnfxvSSmrBh2W8drvP0zI/K4z279+vCxcueE9jXGlt1EK739cG8LCT8EVPRDsJrROgHXv7LDa4
0Yto+xJseaDPm8Zem9bXwtr7bF+DfYZA34YAwN/+ahm74S+sXrWGXTmwwOt1DACM/sZK5Vyp0VRv
ozau262z6RlKO39Ge/bvVVRUjCKj4jUzf0eF6fFec+OO3Yd15VK++83kKjsrW9XNfd527MqCGRgA
zN26o+GeFre9FMWEH9WGTXt02J5WlxqviZFBbd9h45g8XwBg72EjatodWtaGHKg1P9pdL8vRrkB6
za5ec6sF0cPq6e337gyz12nu+ISFHfPu9nmbtLuwTp8+4wKzUa952cZCMO0uJv+dTHbFp6OuXFER
x3QkLFynY08rMeWCyzvz1NTYoJy8TF13BXzexXQdOmLPkMnXifAoXSm8qqzzGZp/IO/pjBmZWa7g
7/S+w46O7lfTBPDcDwNaeBzwX54hU3xTtBGrXgeD7dtSLZ0VNtZ+Zh1SVkN772fNkJ6kncTBtv86
aUFisH1f6ttyBcA6S1lhbG2PdonX9L+2QNU/v/T/wdL4/780zdJldjXJRmazy92v6xWAG8M9Oh9/
Xheys1zt9oBizsZr8/ffacvWTToWnazL+ZfUOTChhvKrijoWrujYZJVXX9eJ6CgdPxmvpq5hb1uP
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
AAQAiPiWSQCw+hIArIx0AkREDJAAYPUlAFgZ6QOAiBggAcDqSwCwMtIHABExQAKA1ZcAYGWkDwAi
YoAEAKsvAcDKSB8ARMQACQBWXwsAtmzZpvDw4/rNb37tFVT48v2jO87vvvt3AgBERJMAYPW17+Db
b7/XhZw8xcSe1pm4eHwFnj4dp8TERPUNjap99A4BACKGtgQAr4/vv/+B/vnPj/XRP/+Jr8APPvhQ
n3/+udq6eukEiIhIAPD6aM/fwFennevvvvsPOgEiIpoEABgqWj8AOgEiIi5IAICh4qIAgIGAEDHU
JQDAUHF5AQBNAIj4lhkYAMzOzmp+fl5zc3O6f/8+AQC+VS6vCYAAABHfMv0BwMzMjIaGhtTU1KSW
lhbdunVLERERBAD41kgfAETEAP0BgNX+Ozo6dPToUSUkJOj27ds6ceIEAQC+NdIHABExQH8AYO3+
dvm/qqpKnZ2dMmgCwLdJAgBExAAtAPjyyy+9dv87d+54nf/u3r3rBQCRkZH6zW9+E3Q9xDdNOgEi
Igb417/+Ve+99562bt26yB07duizzz7zMs1g6yG+aS6vDwABACK+hVoQ8M4773hPogvUMsy//e1v
QddBfNNcXgBAEwAiIuIb6fKaAAgAEBER30iXFwDQBICIiPhGSh8ARETEEJQ+AIiIiCEofQAQERFD
UAIARETEEJROgIiIiCEonQARERFDUDoBIiIihqD0AUBERAxB6QOAiIgYgtIHABERMQQlAEBERAxB
6QSIiIgYgtIJEBERMQSlEyAiImIISh8ARETEEJQ+AIiIiCEofQAQERFDUPoAICIihqD0AUBERAxB
CQAQERFDUDoBIiIihqB0AkRERAxB6QSIiIgYgtIHABERMQSlDwAiImIISh8ARETEEJQAABERMQSl
EyAiImIISidARETEEJROgIiIiCEofQAQERFDUPoAICIihqD0AUBERAxB6QOAiIgYgtIHABERMQQl
AEBERAxB6QSIiIgYgtIJEBERMQSlEyAiImIISh8ARETEEJQ+AIiIiCEofQAQERFDUPoAICIihqD0
AUBERAxBCQAQERFDUDoBIiIihqB0AkRERAxB6QSIiIgYgtIHABERMQSlDwAiImIISh8ARETEEJQ+
AIiIiCEofQAQERFDUAIARETEEJROgIiIiCEonQARERFDUDoBIiIihqD0AUBERAxB6QOAiIgYgtIH
ABERMQSlDwAiImIISh8ARETEEJQAABERMQSlEyAiImIISidARETEEJROgIiIiCEofQAQERFDUPoA
ICIihqD0AUBERAxBCQAQERFDUDoBIiIihqB0AkRERAxB6QSIiIgYgtIHABERMQSlDwAiImIISh8A
RETEEJQ+AIiIiCEofQAQERFDUAIARETEEJROgIiIiCEonQARERFDUDoBIiIihqD0AUBERAxB6QOA
iIgYgtIHABERMQQlAEBERAxB6QSIiIgYgtIJEBERMQSlEyAiImIISh8ARETEEJQ+AIiIiCEofQAQ
ERFDUPoAICIihqD0AUBERAxBCQAQERFDUDoBIiIihqB0AkRERAxB6QSIiIgYgtIHABERMQSlDwAi
ImIISh8ARETEEJQ+AIiIiCEofQAQERFDUAIARETEEJROgIiIiCEonQARERFDUDoBIiIihqD0AUBE
RAxB6QOAiIgYgtIHABERMQSlDwAiImIISh8ARETEEJQAABERMQSlEyAiImIISidARETEEJROgIiI
iCEofQAQERFD0JfSB+CPf/iDtyFERER8M/yDK7vfffcfauvqfbEmgO+++14ffvCBPv30U89PPvnk
oUuXPW5+JdIEW/a4+dctjX/+SWmCLXtVafzzy00TbNmLpPHPr2Qa//xKpAm27HHzpHlyGv/8k9IE
W/Y2pPHPLzdNsGUvkmbp/JPSBFv2Imn88yuRJtiyx82vRJpgyz7++GM3/VgtHd3PfwWgun1Ya9as
0dmzZ5Wenq7U1FRERER8A8zMzNTx8GOqbWhR18SD5wsAqtqG9MMPG5SSkuJtKCMjAxEREd8As7Oz
FRtzSnWNrS8WAKxf/4OSk5O9jdlVAERERHz9zcrK0qnok8sPAGxjaWlpiIiI+AZoV+5fPABoHdJ3
332nhIR4ZWS4iCItFREREd8As1wAcOL4MdU1ND9fADAyLzV0T6rGrdjZ06/egWH19A8hIiLiG6CV
263tXeofmVLr8K1nCwCOR57yrgDYCt2TD9Qxdk/tY3cRERHxTXH0rnf7X9vIbe91++CNpwcA+w4e
SR+dvedFC4iIiPhma4V/a+/Y0wMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAeL35b//t/wdkkLdJqDzWawAAAABJRU5ErkJggg==</Preview>
  <Form>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</Form>
  <Code><![CDATA[class config_customerinfo {
	[string]$customername
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	
}
$tools_winget_label_Load = {
	Set-ControlTheme $tools_winget_label -Theme Dark
	
	try
	{
		$config_import_csv = Import-Csv "config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('See: https://github.com/rink-turksma/IntunePrepTool ', 'config_customerinfo.csv missing')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($winget_exe.count -gt 1)
		{
			$winget_exe = $winget_exe[-1].Path
		}
		
		if (!$winget_exe)
		{
			
			[void][System.Windows.Forms.MessageBox]::Show('Winget expected in C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\ ', 'Winget missing') # Casting the method to [void] suppresses the output.  }
			
		}
		else
		{
			if (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			}
		
		}
		
		
		
	}
	$restrictionpolicy = Get-ExecutionPolicy; if ($restrictionpolicy -ne 'Unrestricted')
	{ [void][System.Windows.Forms.MessageBox]::Show('Please run: "set-executionpolicy unrestricted" ', 'Powershell execution policy must me unrestricted')}
	
	
	try
	{
		
		Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
	}
	catch
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
	}
	#>
	$config_tabcontrol2.Dock = 'Fill'
	$config_tabcontrol2.Visible = $true
	$config_tabcontrol2.Enabled = $true
	
	
	
	
}


$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $tools_winget_label -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $tools_winget_label -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$versie = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$wingetID\$versie\source" -s "$outputDirectory\$wingetID\$versie\source\install.ps1" -o "$outputDirectory\$wingetID\$versie\output" -q
	
	Rename-Item -Path "$outputDirectory\$wingetID\$versie\output\install.intunewin" -NewName "$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Versie `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Versie `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$wingetID.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $versie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$wingetID\$versie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$wingetID\$versie\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$winget_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {

	$wgid = $winget_WingetID_textbox1.text

	
		$showurl = winget show $wgid --accept-source-agreements
		foreach ($l in $showurl)
		{
			if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
		}
		
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	[string]$c_tenanturl = $config_tenanturl_textbox.text
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	
	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			tenanturl	    = $c_tenanturl;
			downloadpath    = $c_downloadfolder;
		})
	
	$config_customerinfo | Export-Csv "config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			if ($config_customerinfo.customername -eq $cis.customername)
			{
				Update-ListBox $config_listbox $cis.customername -Append
			}
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else {
		
		if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
		{
			
			New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
		{
			
			New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
		}
		$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
		$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
		$exe_output_textbox1.AppendText("`r`n")
		$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
		
		[string]$exe_org_path = $exe_openfiledialog1.FileNames
		try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false 
			Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
			$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
			$exe_panel1.Enabled = $true
			$exe_panel1.Visible = $true
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
		}
		$exe_open_sourcedir_button1.Enabled = $true
		$exe_open_sourcedir_button1.Visible = $true
		}
	}
		
		
	}
	
	$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true


	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	

}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true

	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")
	$exe_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$exe_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
}

$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_output_textbox1.AppendText("`nYou can use this for TRANSFORMS files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			 #$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSIbestand"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:53
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
	write-host $startPMSI
	$msilog = get-content $logfileMSI
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Script started i.cmd" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
		write-host ""
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green

	}
	
	if ($msiuninstallcode -eq $null) { $excode = 1 ; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
    Else
    {
        write-host "Script started i.cmd" -ForegroundColor Green
        write-host "Possible uninstall command is:" -ForegroundColor Green
        write-host ""
        write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
        write-host ""
        Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
        write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
        $excode = 0
    }
   
	
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content $logfileMSI 
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue


    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	#$msi_installFile = $msi_installFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true
	$msi_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msi_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
	
			$config_csv_openfiledialog1.ShowDialog()
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			$upload_DisplayName_textbox1.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox1.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
		if (!(test-path "$filepath\Logo.png" -PathType Leaf))
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please use the button: Upload Logo after creating Intunewin file', 'Upload Logo first')
			$upload_logo_button2.Enabled = $true
			$upload_logo_button2.Visible = $true
			
		}
		
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2022 v5.8.210
	 Created on:   	26/02/2023 14:05
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
	.DESCRIPTION
		Params are used from IntunePrepTool
		Uses Powershell modules MSAL.PS from Jason Thompson and IntuneWin32App from Nickolaj Andersen
		
#>

#Requires -RunAsAdministrator
#Installatie Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Galery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App) { Import-Module -Name IntuneWin32App -Force }
else { Install-Module -name IntuneWin32App -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False -RequiredVersion "1.4.1"; Import-Module -Name IntuneWin32App -Force }
Write-host "Script will update IntuneWin32App when needed" -ForegroundColor Green
if ((Get-Module -ListAvailable -Name IntuneWin32App).Version -ne "1.4.1") {
Update-Module IntuneWin32App -confirm:$false -Force
}
else {
write-host "IntuneWin32App module already on version 1.4.1" -ForegroundColor Green
}
Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
[string]$config_csv_path = '!!CONFIGCSV!!'
$tenantURL = "!!TENANTURL!!"
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
Write-host "First logon with the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

Connect-MSIntuneGraph -TenantID $tenantURL -Interactive
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
$logoaanwezig = get-childitem "$filepath\logo.png"
if ($logoaanwezig -eq $null) { write-host "No Logo.PNG found in Output Directory" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
else
{
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
	
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
	write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam -Verbose
	if ($Win32AppEvtVorigeVersies -ne $null)
	{
		write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
		write-host $evtvversie
		$alversieAppAanwezig = $true;
		write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	}
	
	else
	{
		$alversieAppAanwezig = $false;
	}
	
	write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience "system" -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose
	Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	
	if ($SetupLikeOldVersion -eq $true)
	{
   <#
	
	$response = read-host "Press q to do nothing, Any other key for setting up dependencies. Dependency will be the same if older version. (When exists)"
	$niksdoen = $response -eq "q"
	if ($niksdoen -eq $true) { write-host "Ok.. We won't do this" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		if ($dep -notlike $null)
		{
			$dependency = Get-IntuneWin32App | Where-Object { $_.Displayname -like $dep }
			$dep2 = New-IntuneWin32AppDependency -DependencyType AutoInstall -ID $dependency.Id
			Add-IntuneWin32AppDependency -ID $Win32App.Id -Dependency $dep2 -Confirm:$false
			write-host "Dependency done"; Write-host "`r`n"; Write-host "`r`n";
		}
		else { write-host "No dependency found in older version" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	}
#>
		
		if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
		else
		{
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
				$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
				$evtvversie = $vorigeversie.DisplayVersion
				
				if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host ""; Write-host "`r`n"; Write-host "`r`n"
					$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
					$niksdoen = $response -eq "q"
					if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
					else
					{
						write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
						Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
						try
						{
							Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
						}
						catch
						{
							Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
						}
					}
				}
			}
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Write-host "We will fix superseedence for:" -ForegroundColor Green
					$vorigeversie.displayVersion
					
					$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
					$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
					if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
					Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
				}
			}
			
			
			
		}
		
		
	}
	if ($AvailableAllUsers -eq $true)
	{
		
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll -Verbose
		
	}
	
	
	if ($RequiredAllDevices -eq $true)
	{
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll -Verbose
		
		
		
		
	}
	
}


'@
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$tenanturl = $upload_tenantURL_textbox.text
	$depWin = $upload_dep_textbox1.Text
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!TENANTURL!!', $tenanturl)
	$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
	if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
	}
	if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
	}
	if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
	}
	else
	{
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
	}
	
	
	
	
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$uploadIntuneFile | Out-File $filepath\uploadIntune.ps1 -Force
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE?; After uploading: Please reopen IntunePrepTool to create another package ', 'Upload to Intune', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		powershell_ise -file $filepath\uploadIntune.ps1
	}
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$fid = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$fid\$wid\$vid\Output\logo.png" -ErrorAction Stop
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
	
	
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\output\logo.png" -ErrorAction Stop
	$msi_output_textbox1.AppendText("`r`n")
	$msi_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]
		$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]
		$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Item,
	    [Parameter(Mandatory=$false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
	-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param(
	$InputObject, 
	[ValidateNotNull()]
	[System.Data.DataTable]$Table,
	[switch]$RetainColumns,
	[switch]$FilterCIMProperties)
	
	if($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @(,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_tenanturl_textbox.text = $cis.tenanturl;
			$upload_tenantURL_textbox.text = $cis.tenanturl
			$config_download_folder_textbox3.Text = $cis.downloadpath
			
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "C:\Program Files\IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_tenanturl_textbox.text = "Enter Intune Tenant Url; Example CSNtestRink.onmicrosoft.com"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;		
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					tenanturl	    = $cis.tenanturl;
				})
		}
		
		
	}
	$config_customerinfo | Export-Csv "config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$vid = $versie_textbox2.Text
		if ($vid -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			
			
			$wid = $winget_WingetID_textbox1.text
			
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			
			
			$WinGetID = $wid
			$regApp1 = $DisplayName
			$versie = $vid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			
			$installFile = @'
	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	16-5-2023 15:20
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:      Winget_install_uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be provided from IntunePrepTool
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$versie.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
Write-Host "Script will install Microsoft.WinGet.Client powershell module from the Powershell Galery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.WinGet.Client) { Import-Module -Name Microsoft.WinGet.Client -Force }
else { Install-Module -name Microsoft.WinGet.Client -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name Microsoft.WinGet.Client -Force }

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>

$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

if (!$winget_exe) { Write-Error "Winget not installed" $excode = 1 }
else { $excode = 0 }

try
{
	
	$install = "!!WingetCommand!!"
if ($install -like "!!doe*")
{
	if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
	{
		& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
		<#
		try
		{
			#install-wingetPackage -Scope System -Id $WinGetID -Force -confirm:$false -ErrorAction Stop
			
		}
		catch
		{
			
		}
		#>
	}
	if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
	{
		& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale

		<#
		try
		{
			install-wingetPackage -Scope System -Id $WinGetID -Force -confirm:$false -ErrorAction Stop
		}
		catch
		{
			
			
		}
		#>
	}
	if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
	{

		& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
		<#
		try
		{
			install-wingetPackage -Scope System -Id $WinGetID -Force -confirm:$false -Version $versionWinget -ErrorAction Stop
			
		}
		catch
		{
			
		}
		#>
	}
	
	if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
	{
		& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		<#
		try
		{
			install-wingetPackage -Scope System -Id $WinGetID -Force -confirm:$false -Version $versionWinget -ErrorAction Stop
		}
		catch
		{
			
		}
		#>
	}
}
	else
	{
		& $winget_exe uninstall --id $WinGetID -h
	}
	#$excode = 0;
	
}
catch
{
	#$excode = 1;
	
}

if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
}
#### Place extra actions here:




<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error';  }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!versie!!', $versie)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			
			
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\output"
			}
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$wingetID\$versie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
		}
	}
	
}

$winget_test_install_button1_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\install.ps1"
	}
	
}

$winget_uninstall_test_button_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\uninstall.ps1"
	}
	
	
}

$winget_show_version_button1_Click={
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click={
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);

	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
				
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
		
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
		
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			  
			
			
			
			
			
			
		}
		
	}
	
	

	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click={
	#TODO: Place custom script here
	if ( $config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click={
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged={
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click={
	#TODO: Place custom script here
	$upload_logo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $upload_logo_openfiledialog1.FileNames
	
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	
	$itwnf = $ConfigCSVImport.IntuneWinFile
	$filepath = $config_csv_path.TrimEnd("config.csv")
	Copy-Item -Path $logo_org_path -Destination "$filepath\logo.png"
}

$timer1_Tick={
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'C:\Program Files (x86)\IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'C:\Program Files (x86)\IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'C:\Program Files (x86)\IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click={
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files (x86)\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files (x86)\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files (x86)\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files (x86)\IntunePrepTool\wingetupdate.ps1"
	}
	
}

$config_check_updates_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$hover_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged={
	#TODO: Place custom script here
	$hover_textbox1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover={
	#TODO: Place custom script here
	$hover_textbox1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click={
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile| Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $true
	$config_tabcontrol2.Visible = $true
	$config_tabcontrol2.Dock = 'Fill'
}

$wingetToolStripMenuItem_Click = {
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
}
$scheduledTaskToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
}


$mSIToolStripMenuItem_Click = {
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
}

$eXEToolStripMenuItem_Click = {
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
}

$main_panel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false

	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
}

$weblinkToolStripMenuItem_Click = {
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
}



$intunewinToolStripMenuItem_Click={
	#TODO: Place custom script here
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	
	
	
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	
}

$wingetSearchShowVersionToolStripMenuItem_Click={
	#TODO: Place custom script here
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabcontrol2.Enabled = $false
	$config_tabcontrol2.Visible = $false
	$config_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	
}


$Weblink_intunewin_tabpage6_Click={
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged={
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged={
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click={
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
			
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
			
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile )
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
	
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	$package_ScheduledTask_create_scripts_button1.Enabled = $true
	$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_combobox1.Enabled = $true
		$package_scheduledtask_combobox1.Visible = $true
		$package_scheduledtask_time_combobox1.Enabled = $true
		$package_scheduledtask_time_combobox1.Visible = $true
		$package_scheduledtask_am_radiobutton1.Enabled = $true
		$package_scheduledtask_am_radiobutton1.Visible = $true
		$package_scheduledtask_pm_radiobutton.Enabled = $true
		$package_scheduledtask_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_combobox1.Enabled = $false
		$package_scheduledtask_combobox1.Visible = $false
		$package_scheduledtask_time_combobox1.Enabled = $false
		$package_scheduledtask_time_combobox1.Visible = $false
		$package_scheduledtask_am_radiobutton1.Enabled = $false
		$package_scheduledtask_am_radiobutton1.Visible = $false
		$package_scheduledtask_pm_radiobutton.Enabled = $false
		$package_scheduledtask_pm_radiobutton.Visible = $false
	
	}
}

$package_scheduledtask_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_time_combobox1_SelectedIndexChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_am_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_pm_radiobutton_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged={
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click={
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click={
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
			
			
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_ScheduledTask_create_scripts_button1.Enabled = $true
				$package_ScheduledTask_create_scripts_button1.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged={
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	$package_scheduledtask_system_panel3.Visible = $true
	$package_scheduledtask_system_panel3.Enabled = $true
	

				
				$ScheduledTaskFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	"!!ps1name!!"
	===========================================================================
	.DESCRIPTION
		Please place your script between:
        "Place your Powershell code here" and "End of your Powershell script"
        When done. Save script and close Powershell_ISE
#>
#App Params
$package_scheduledTask_name  = "!!package_scheduledTask_name!!"
$package_scheduledTask_version = "!!package_scheduledTask_version!!"
#Customer vars
$logdir = "!!logdir!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$package_scheduledTask_name $package_scheduledTask_version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$package_scheduledTask_name"
$excode = $null;
#create log directory in programdata when needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates dll directory in logdir when needed.
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates scheduledTasks directory in logdir when needed.
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
#Create registry key when needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application key in registry when needed
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  This is saved in $logdir. Also used in EventViewer
Start-Transcript -Path $logfile
<# Place your Powershell code here#>






















<# End of your Powershell script#>
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; }

if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
			$logdir = "$config_logfoldertarget\scheduledTasks"
				$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
				$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
				$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
				$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
				$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
				copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
				$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Save when done")
				
				
	
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	


$package_scheduledTask_Edit_script_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click={
	#TODO: Place custom script here

	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
	}
	else
	{
		$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
		$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
		$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
		$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
		$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
		$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
		
		
		$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the creation of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators","Modify","Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System,"Modify","Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	

$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
if ($StartupTask -eq $true) {
	$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
}
else {
	$trigger1 = $null
}
if ($WeeklyTask -eq $true) {
	$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
}
else {
	$trigger2 = $null
}
if (($trigger1 -eq $null) -and ($trigger2 -ne $null)) {
    $triggers = @($trigger2)
}
if (($trigger1 -ne $null) -and ($trigger2 -eq $null)) {
    $triggers = @($trigger1)
}
if (($trigger1 -ne $null) -and ($trigger2 -ne $null)) {
    $triggers = @($trigger1, $trigger2)
}
$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
write-host "Scheduled Task created for $psFile" -ForegroundColor Green

	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
fDetectionInRegistry -succes $true }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		
		$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
		
		
		
		$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
		$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
		$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
		$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
		$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
		

		if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
		}
		if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
			$WeeklyTaskDay = $package_scheduledtask_combobox1.Text
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
			$weeklyTaskHour = $package_scheduledtask_time_combobox1.Text
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
			if ($package_scheduledtask_am_radiobutton1.Checked -eq $true)
			{
				$WeeklyTaskAMPM = "AM"
			}
			else
			{
				$WeeklyTaskAMPM = "PM"
			}
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM )
			
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
		}
		$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
		
		$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
		$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
		$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
		$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
		$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
		
		
		if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
		}
		else
		{
			$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!StartupTask!!", $false)
		}
		if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
		{
			$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!WeeklyTask!!", $true)
			$WeeklyTaskDay = $package_scheduledtask_combobox1.Text
			$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
			$weeklyTaskHour = $package_scheduledtask_time_combobox1.Text
			$ScheduledTaskUnInstall= $ScheduledTaskUnInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
			if ($package_scheduledtask_am_radiobutton1.Checked -eq $true)
			{
				$WeeklyTaskAMPM = "AM"
			}
			else
			{
				$WeeklyTaskAMPM = "PM"
			}
			$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
			
		}
		else
		{
			$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!WeeklyTask!!", $false)
		}
		$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
		
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
		
		

		
	}
	
	
	
	
}

$windowsFirewallToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click={
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'
Write-Host "Script will install Microsoft.WinGet.Client powershell module from the Powershell Galery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.WinGet.Client) { Import-Module -Name Microsoft.WinGet.Client -Force; Write-Host "Powershell module already installed" -ForegroundColor Green }
else { Install-Module -name Microsoft.WinGet.Client -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name Microsoft.WinGet.Client -Force; Write-Host "Installed Powershell module" -ForegroundColor Green }

Write-Host "Script will install Evergreen powershell module from the Powershell Galery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Evergreen) { Import-Module -Name Evergreen -Force; Write-Host "Powershell module already installed" -ForegroundColor Green }
else { Install-Module -name Evergreen -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name Evergreen -Force; Write-Host "Installed Powershell module" -ForegroundColor Green }

'@
	if (!(Test-Path "C:\Program Files (x86)\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files (x86)\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files (x86)\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files (x86)\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files (x86)\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files (x86)\IntunePrepTool\wingetinstallpsmodules.ps1"
	}
}

$downloadToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click={
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click={
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click={
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click={
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	

	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget| Select Name,ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 

}

$download_winget_listbox1_SelectedIndexChanged={
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged={
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory !!@download_winget_path@!! --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files (x86)\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
	}
	
}


$download_winget_explorer_button1_Click={
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click={
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click={
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click={
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
	
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
	$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	try
	{
		$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nUbinstall.ps1 NIET created `r`n")
	}
	}
}

$exe_radiobutton3_CheckedChanged={
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged={
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click={
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken } 
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click={
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $powershell_package_name_textbox1.text
	$exeversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$exepnaam\$exeversie\output\config.csv file there", 'Upload Now?',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
	
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click={
	#TODO: Place custom script here
$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}
]]></Code>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="True">548</Line>
    <Line Disabled="True">1336</Line>
    <Line Disabled="True">1338</Line>
    <Line Disabled="False">1796</Line>
    <Line Disabled="False">3215</Line>
    <Line Disabled="False">4794</Line>
    <Line Disabled="True">5546</Line>
    <Line Disabled="True">5548</Line>
    <Line Disabled="True">5654</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>0</Mode>
  <Assemblies />
</File>