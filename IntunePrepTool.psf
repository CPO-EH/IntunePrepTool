<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>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
A0CSpIQZAJIkJcwAkCQpYQaAJEkJMwAkSUqYASBJUsIMAEmSEmYASJKUMANAkqSEGQCSJCXMAJAk
KWEGgCRJCTMAJElKmAEgSVLCDABJkhJmAEiSlDADQJKkhBkAkiQlzACQJClhBoAkSQkzACRJSpgB
IElSwgwASZISZgBIkpQwA0CSpIQZAJIkJcwAkCQpYQaAJEkJMwAkSUqYASBJUsIMAEmSEmYASJKU
MANAkqSEGQCSJCXMAJAkKWEGgCRJCTMAJElKmAEgSVLCDABJkhJmAEiSlDADQJKkhBkAkiQlzACQ
JClhBoAkSQkzACRJSpgBIElSwgwASZISZgBIkpQwA0CSpIQZAJIkJcwAkCQpYQaAJEkJMwAkSUqY
ASBJUsIMAEmSEmYASJKUMANAkqSEGQCSJCXMAJAkKWEGgCRJCTMAJElKmAEgSVLCDABJkhJmAEiS
lDADQJKkhBkAkiQlzACQJClhBoAkSQkzACRJSpgBIElSwgwASZISZgBIkpQwA0CSpIQZAJIkJcwA
kCQpYQaAJEkJMwAkSUqYASBJUsIMAEmSEmYASJKUMANAkqSEGQCSJCXMAJAkKWEGgCRJCTMAJElK
mAEgSVLCDABJkhJmAEiSlDADQJKkhBkAkiQlzACQJClhBoAkSQkzACRJSpgBIElSwgwASZISZgBI
kpQwA0CSpIQZAJIkJcwAkCQpYQaAJEkJMwAkSUqYASBJUsIMAEmSEmYASJKUMANAkqSEGQCSJCXM
AJAkKWEGgCRJCTMAJElKmAEgSVLCDABJkhJmAEiSlDADQJKkhBkAkiQlzACQJClhBoAkSQkzACRJ
SpgBIElSwgwASZISZgBIkpQwA0CSpIQZAJIkJcwAkCQpYQaAJEkJMwAkSUqYASBJUsIMAEmSEmYA
SJKUMANAkqSEGQCSJCXMAJAkKWEGgCRJCTMAJElKmAEgSVLCDABJkhJmAEiSlDADQJKkhBkAkiQl
zACQJClhBoAkSQn7Xw+AF77/Yjz++J/GU089JUmSHpKeeOKJePaZff+zAbCweTteeunleGbfX5YV
8TeSJOkh6dl9fxU//uGLcfn61xwA2x9GzFy8EWtb18p6+CC2rkqSpIelzXuP61c+jIWtj/Y2AA68
erDlyt2Ixe2PYmnnbr0cJEnSw9fC1p1YvvofsbB+/asHwD/89KVTWzc+irm1K5Ik6SFvceNGzCxt
fPUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5m
jzzyX8ZAaodsNMbKAAAAAElFTkSuQmCC</Preview>
  <Form>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
hrQSZUAr8fv//apXiy6Z1WBMOLo2NT5mY/ld1xzJ4l+oRGX3J7+WNpNf6asUq4RPqXJYi/BEC8HN
No9LkYYKX7JwOSz9d5Aw2KvfkUsH3fqhy5dNli0jyYK6/lt6zNSaq/hDcaSkwZ9qqzPOd0bgb1n4
Mj3Kpp/BfzKfoqzG4Q8yxUGm3cmn0+ViPUt+jDMN8LPcy30zX+jc3jzlh/okpdeLdL/zMXxvl+SJ
ps/lx5fmcHZHpZvzl8W8o3e0h+nj4/rxYd6s0FJr3olR2bU0vm/E26NR7Y0qNTOfWv72ppevrOh0
TyrmeK6eWidzrVY6P7rn4q0m+zRWxMpzry3Sw2Llsfq2lqqlJ7FZemFq5HOXk5fgf0WuTrWnsYle
fIzd3qSp9/dnltc79+lZp5sny6t5rTt9S/GJ4n09v+Lq6Wo1kc7HR60Jpw7fxWqZuxeKXLVRqwzG
TO6zrLSLlcaoqnykU7c3+rrIkmxuFBtTWbKdzS+kfEl/rjR6o4/0vMRlBZoZpx8esu3nSVvox8fV
4bi6mi4Ts3Qm+yKI8exKoe9bM0F/6Qxub4RhbjZrPpUeEstSopuIi59vuqqWcg3jXezD57wYv2fJ
Qj4uaerTHZuku8oo2cgt2HSZH3OKyj6zo7ycWc/L2dub+lspv1gWErUin3yTU53UoEOtn+tSftmO
rZtMLvO4YPQ6895YzYTCeMA2mpX3RPqZr/MsLc27+fmiHaOz5Xhdn2dub+762YK0fHkf1eMPT+Pn
x/Z0sdSfOuLi4fnjrt6vP5cKU7bV4WpqP70cDmv8Ip0aZoQZSVUeqlJn3lxK9eqMocf6kr29Wajv
9dRno92riZVFjmH5Z+6dTMSNd7behsklNdQVPs2+LJ67qYGoZvKtNaUL1KA9XpJcByBRGj8XH5ts
I313e/NezPZWlVjlU3qgl9l77m226r3l77u02qQW5Q5FD1O57ER5uucfnpqf5awoZlPtWO9jpLE5
XgOq6/6jdc+05YfUnXx78zHrjaoFUki95XLVz1Wm2/38aC5zuWW7xpKp1FqWyELq+UN7U5Jj8jGm
xTOPSX2ZfM/VhrmPj8/3dCZfmH6UHmdsWwB4a3ZTS/H5niulyA8uVu73p232XeurDe0tRq84ptek
YkymfF+Vyfhq9lQYP73nuGyRWchUm070CstCvNRKcC9PyhPYBU7V4gUqni83huKyX7qTVtN8Qc9M
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
m94w07AuXZhRpGFt1+MflIe1+A8yERsQVh1JDDMV69gbZ/sxI4x5Msi96Fzs8Yp+cTL2MqKNgbD+
CTbwjVpFkcEKRm5b2wtRuwQ6nsSBbFBCRE5Ke7xQL2JNCqp0CWS0BPCBiyBk4SIyWL4gFeeC9wUP
FCP6cRLtwxdE6R0IzRc8WA+/ruClXwFttw6a8aVmt46nS1G+pPPIqccQFeUH3KA2JSdZx3sn3KFN
e596HlzLUaSnNO3dYsPeVegL+71Ph6YDKes4pQxdy8GxQ5gxhAuO8Q9RHLop19CyoTMZTghyug9f
HHhEf2q50EQ1IGmAdjaYGqcDssIVBcRLqXyIAoC0erGScLwJ+HJwjf4FZNy0x1hD7Px7F3BUUhJ1
XPdZXhB9C46DxbUI8xZ3voX3aS3B+RYRpyuNdd78aJu58qtT4agw9MtKUSgMVb1iZCtrMnG2Hz/S
lKX9sn51xjIssNdtlQq0Xa+CPlFGirxj2XgZAOKdtYcT4JGpDBf16Pf1pnUClc4vgTzywobvKEQa
TuYHkg5+pEoz/dW8eaIMVsHPuGb/l30kYPl0ynt47xaUuvOH6FAYF9w43FfgLkEIyQpTfhK/COsi
EEgv8Xu9Wvzy0c+Yno3NyDScvbja+YHnme0b15iZg5cAFdFKF/81wuXAI7KExXElDPXGLu4XYV0v
t52I9Z0EzGE/gpeyS8mjY03RDkScgop0D7jBinVxRnfR3pPvOICtC5Kse+L41Xirg8N1QRGFfRRl
saLIKAPlztT5uAxrRYucT4i7gqC5ddFB88mKfpd42bWsSdMFVV/MAi1mc1Y/WLVsJyReQaRs0XyZ
SHda139woKyLmr4bCB2BO1+aAgJt5CwjyYK6/lt6zNSaq/hDcaSkwZ9qqzPOd0bgb1n4Mj3Kpp/B
fzKfoqzG4Q8yxUGm3cmn0+ViPUt+jDMN8LPcy30zX+jc3jzlh/okpdeLdL/zMXxvl+SJps/lx5fm
cHZHpZvzl8W8o3e0h+nj4/rxYd6s0FJr3olR2bU0vm/E26NR7Y0qNTOfWv72ppevrOh0TyrmeK6e
WidzrVY6P7rn4q0m+zRWxMpzry3Sw2Llsfq2lqqlJ7FZemFq5HOXk5fgf0WuTrWnsYlefIzd3qSp
9/dnltc79+lZp5sny6t5rTt9S/GJ4n09v+Lq6Wo1kc7HR60Jpw7fxWqZuxeKXLVRqwzGTO6zrLSL
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
BQUOc9GRBQA=</Form>
  <Code><![CDATA[class config_customerinfo {
	[string]$customername
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			#$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function refreshTenantsUpload
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$upload_treeview2.BeginUpdate()
		$upload_treeview2.Refresh()
		$upload_treeview2.Nodes.Clear()
		$upload_treeview2.CheckBoxes = $true
		$Root = $upload_treeview2.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			#$upload_treeview2.Nodes.Add($tenantCSV.customername)
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			
			
		}
		$Root.Expand()
		$upload_treeview2.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function PowershellISEOnTop
{
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}
}



$tools_winget_label_Load = {
	Set-ControlTheme $tools_winget_label -Theme Dark
	
	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			Update-ListBox $update_exe_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($winget_exe.count -gt 1)
		{
			$winget_exe = $winget_exe[-1].Path
			& $winget_exe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
		}
		
		if (!$winget_exe)
		{
			
			[void][System.Windows.Forms.MessageBox]::Show('Winget expected in C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\ ', 'Winget missing') # Casting the method to [void] suppresses the output.  }
			
		}
		else
		{
			if (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			}
			
		}
		
		
		
	}
	$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
	if ($restrictionpolicy -ne 'Unrestricted')
	{
		
		if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		{
			$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
			if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
			{
				powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
			else
			{
				$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
				Start-Sleep 1
				powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
			}
		}
		
		
		try
		{
			
			Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
		}
		catch
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		}
	}
	
	$problemPSModule = $null;;
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
		{
			
		}
		else
		{
			$problemPSModule = 1
		}
	}
	else
	{
		$problemPSModule = 1
		
	}
	if ($problemPSModule -eq 1)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	try
	{
		
		Get-ChildItem -Path "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -ErrorAction Stop
	}
	catch
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: Download Winget MSIX bundle', 'Winget MSIX bundle missing') # Casting the method to [void] suppresses the output. 
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	}
	
	if (!(test-path -path 'C:\ProgramData\chocolatey'))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: "Install Chocolatey"', 'Chocolatey missing') # Casting the method to [void] suppresses the output. 
		
	}
	
	
	
	refreshTenants
	refreshTenantsUpload
	#>
	$config_tabpage.Dock = 'Fill'
	$config_tabpage.Visible = $true
	$config_tabpage.Enabled = $true
	
	
	
	
}


$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $tools_winget_label -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $tools_winget_label -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$versie = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$wingetID\$versie\source" -s "$outputDirectory\$wingetID\$versie\source\install.ps1" -o "$outputDirectory\$wingetID\$versie\output" -q
	
	Rename-Item -Path "$outputDirectory\$wingetID\$versie\output\install.intunewin" -NewName "$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\$wingetID.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Versie `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Versie `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$wingetID.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $versie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$wingetID\$versie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$wingetID\$versie\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$winget_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {
	
	$wgid = $winget_WingetID_textbox1.text
	
	
	$showurl = winget show $wgid --accept-source-agreements
	foreach ($l in $showurl)
	{
		if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
	}
	
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	
	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
		})
	
	
	$existing_customerinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$filtered_customerinfo = $existing_customerinfo | Where-Object { $_.customername -ne $config_customerinfo.customername }
	$filtered_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Force
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		$config_listbox.ClearSelected()
		$config_listbox.Items.Clear()
		$config_listbox.Refresh()
		foreach ($cis in $config_import_csv)
		{
		
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			Update-ListBox $update_exe_listbox1 $cis.customername -Append
			
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$exepnaam = $exepnaam -replace (" ", "")
	$exe_packagenaam_textbox1.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
			$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
			
			[string]$exe_org_path = $exe_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false
				Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
				$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
				$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
				$exe_panel1.Enabled = $true
				$exe_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
			}
			$exe_open_sourcedir_button1.Enabled = $true
			$exe_open_sourcedir_button1.Visible = $true
		}
	}
	
	
}

$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true
	
	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")
	$exe_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$exe_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msipnaam = $msipnaam -replace (" ", "")
	$msi_packagenaam_textbox1.text = $msipnaam
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			#$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:53
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
	write-host $startPMSI
	$msilog = get-content $logfileMSI
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Script started i.cmd" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
		write-host ""
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green

	}
	
	if ($msiuninstallcode -eq $null) { $excode = 1 ; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
    Else
    {
        write-host "Script started i.cmd" -ForegroundColor Green
        write-host "Possible uninstall command is:" -ForegroundColor Green
        write-host ""
        write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
        write-host ""
        Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
        write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
        $excode = 0
    }
   
	
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content $logfileMSI 
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue


    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	#$msi_installFile = $msi_installFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true
	$msi_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msi_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
		
		$config_csv_openfiledialog1.ShowDialog()
		[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
		$ConfigCSVImport = Import-Csv $config_csv_path
		#Write-Host $ConfigCSVImport
		$itwnf = $ConfigCSVImport.IntuneWinFile
		$filepath = $config_csv_path.TrimEnd("config.csv")
		$itwnffilepath = $filepath + $itwnf
		$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
		$upload_DisplayName_textbox1.Text = $ConfigCSVImport.DisplayName
		$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
		$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
		$upload_reglocation_textbox1.Text = $ConfigCSVImport.reglocation
		$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
		$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
		$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
		if ($ConfigCSVImport.context)
		{
			$context = $ConfigCSVImport.context
		}
		else
		{
			$context = 'system'
		}
		$upload_context_textbox1.Text = $context
		
		
		if (!(test-path "$filepath\Logo.png" -PathType Leaf))
		{
			[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
			$upload_logo_button2.Enabled = $true
			$upload_logo_button2.Visible = $true
			
		}
		
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2022 v5.8.210
	 Created on:   	26/02/2023 14:05
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
	.DESCRIPTION
		Params are used from IntunePrepTool
		Uses Powershell modules MSAL.PS from Jason Thompson and IntuneWin32App from Nickolaj Andersen
		
#>

#Requires -RunAsAdministrator
#Installatie Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name IntuneWin32App -RequiredVersion 1.4.4 -Force
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Authentication -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Applications -RequiredVersion 2.18.0 -Force
}

Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name CredentialManager -RequiredVersion 2.0.0 -Force
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	Import-Module -Name Microsoft.Graph.Identity.SignIns -RequiredVersion 2.18.0 -Force
}

[string]$config_csv_path = '!!CONFIGCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain') {
		$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
		$tenantID = $checkCredLoad.TargetName
		$tenantID = $tenantID.Split("_")[1]
		$AppId = $checkCredLoad.UserName
		$Secret = $checkCredLoad.Password
		}
		else {
		$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
		$tenantID = $cust.tenantID
		$AppId = $cust.appId
		$Secret = $cust.clientsecret

		}
	}
}

Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$regvalue = $ConfigCSVImport.RegValue
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
if ($ConfigCSVImport.context) {
$context = $ConfigCSVImport.context
}
else {
$context = 'system'
}

$logoaanwezig = get-childitem "$filepath\logo.png"
if ($logoaanwezig -eq $null) { write-host "No Logo.PNG found in Output Directory" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
else
{
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}

	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName $regvalue -StringComparisonOperator equal -StringComparisonValue $versie
	$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
	write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam -Verbose
	if ($Win32AppEvtVorigeVersies -ne $null)
	{
		write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
		write-host $evtvversie
		$alversieAppAanwezig = $true;
		write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	}
	
	else
	{
		$alversieAppAanwezig = $false;
	}
	
	write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	 if ($logoaanwezig -eq $null) { 
        $Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose }
    else
    {
	$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description "Upload package by IntunePrepTool" -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -Verbose
    }
	Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	
	if ($SetupLikeOldVersion -eq $true)
	{
   <#
	
	$response = read-host "Press q to do nothing, Any other key for setting up dependencies. Dependency will be the same if older version. (When exists)"
	$niksdoen = $response -eq "q"
	if ($niksdoen -eq $true) { write-host "Ok.. We won't do this" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		if ($dep -notlike $null)
		{
			$dependency = Get-IntuneWin32App | Where-Object { $_.Displayname -like $dep }
			$dep2 = New-IntuneWin32AppDependency -DependencyType AutoInstall -ID $dependency.Id
			Add-IntuneWin32AppDependency -ID $Win32App.Id -Dependency $dep2 -Confirm:$false
			write-host "Dependency done"; Write-host "`r`n"; Write-host "`r`n";
		}
		else { write-host "No dependency found in older version" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	}
#>
		
		if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
		else
		{
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
				$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
				$evtvversie = $vorigeversie.DisplayVersion
				
				if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host ""; Write-host "`r`n"; Write-host "`r`n"
					$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
					$niksdoen = $response -eq "q"
					if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
					else
					{
						write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
						Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
						try
						{
							Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
						}
						catch
						{
							Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
						}
					}
				}
			}
			
			foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
			{
				$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Write-host "We will fix superseedence for:" -ForegroundColor Green
					$vorigeversie.displayVersion
					
					$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
					$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
					if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
					Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
				}
			}
			
			
			
		}
		
		
	}
	if ($AvailableAllUsers -eq $true)
	{
		
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll -Verbose
		
	}
	
	
	if ($RequiredAllDevices -eq $true)
	{
		
		write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
		Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll -Verbose
		
		
		
		
	}
	
'@
	function Get-CheckedNodes
	{
		param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes)
		
		foreach ($Node in $NodeCollection)
		{
			if ($Node.Checked)
			{
				[void]$CheckedNodes.Add($Node)
			}
			Get-CheckedNodes $Node.Nodes $CheckedNodes
		}
	}
	$CheckedNodes = New-Object System.Collections.ArrayList
	Get-CheckedNodes $upload_treeview2.Nodes $CheckedNodes
	
	foreach ($node in $CheckedNodes)
	{
		[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
		$depWin = $upload_dep_textbox1.Text
		$tenantName = $node.Name
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
		$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
		if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
		{
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
		}
		else
		{
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
		}
		if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
		{
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
		}
		else
		{
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
		}
		if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
		{
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
		}
		else
		{
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
		}
		
		
		
		
		$filepath = $config_csv_path.TrimEnd("config.csv")
		$tenant = $node.Name
		$uploadFile = $filepath + "\uploadIntune" + $tenant + ".ps1"
		$uploadIntuneFile | Out-File $uploadFile -Force
		
		if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		{
			Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -File $uploadFile"
			#powershell -file $filepath\uploadIntune.ps1
			#Start-Sleep 1
			#PowershellISEOnTop
		}
		
	}
	
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$fid = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$fid\$wid\$vid\Output\logo.png" -ErrorAction Stop
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
	
	
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msi_output_textbox1.AppendText("`r`n")
	$msi_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
		[ValidateNotNull()]
		[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
		[ValidateNotNull()]
		[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		$Item,
		[Parameter(Mandatory = $false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView])
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param (
		$InputObject,
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterCIMProperties)
	
	if ($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @( ,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					downloadpath    = $cis.downloadpath
				})
		}
		
		
	}
	
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkName = $weblinkName -replace (" ", "")
	$weblink_packagename.Text = $weblinkName
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click = {
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$vid = $versie_textbox2.Text
		if ($vid -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			
			
			$wid = $winget_WingetID_textbox1.text
			
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			
			
			$WinGetID = $wid
			$regApp1 = $DisplayName
			$versie = $vid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$wingetID\$versie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$wingetID\$versie\output"
			}
			if ($winget_install_winget_checkbox1.Checked -eq $true)
			{
				$includeWingetRequirment = $true
				Copy-Item "C:\Program Files\IntunePrepTool\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" "$outputDirectory\$wingetID\$versie\source\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -Force
				
			}
			else
			{
				$includeWingetRequirment = $false
			}
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	18-5-2024 03:27
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$versie.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
if ($includeWingetRequirment -eq $true)
{
        Add-ProvisionedAppxPackage -online -PackagePath ".\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -SkipLicense -ErrorAction SilentlyContinue
		Start-Sleep 5
		$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
		if ($ResolveWingetPath)
		{
			$WingetPath = $ResolveWingetPath[-1].Path
		}
		$wingetexe = $ResolveWingetPath
		
		if (Test-path $wingetexe)
		{
			Write-host "Installation Winget success."
		}
		else
		{
			Write-Host "Installation Winget Failed."
		}
	
	
}

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>




$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

if (!$winget_exe) { Write-Error "Winget not installed" $excode = 1 }
else { $excode = 0 }

try
{
	
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine

		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget

		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			& $winget_exe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		}
	}
	else
	{
		& $winget_exe uninstall --id $WinGetID -h
	}
	
	
}
catch
{	
}
if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
}
#### Place extra actions here:




<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!versie!!', $versie)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$wingetID\$versie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$wingetID\$versie\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$versie\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
		}
	}
	
}

$winget_test_install_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$winget_uninstall_test_button_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$winget_show_version_button1_Click = {
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click = {
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			
			
			
			
			
			
			
		}
		
	}
	
	
	
	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click = {
	#TODO: Place custom script here
	if ($config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click = {
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click = {
	#TODO: Place custom script here
	$upload_logo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $upload_logo_openfiledialog1.FileNames
	
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	
	$itwnf = $ConfigCSVImport.IntuneWinFile
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$filepath\logo.png"
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
}

$timer1_Tick = {
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click = {
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$hover_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged = {
	#TODO: Place custom script here
	$hover_textbox1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover = {
	#TODO: Place custom script here
	$hover_textbox1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
	
	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}

$chocolateyFindToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}
$chocolateyFindToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$chocolateyToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}






$Weblink_intunewin_tabpage6_Click = {
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click = {
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
				
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile)
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
		
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
		
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click = {
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_name = $package_scheduledTask_name -replace (" ", "")
				$powershell_package_name_textbox1.Text = $package_scheduledTask_name
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
				
				
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click = {
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	6-10-2024 17:54
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -executionpolicy bypass -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Settings $settings -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				Write-Host "Eerste stap"
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			Write-Host "Check"
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
			
			if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
			}
			
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			Write-Host "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
			
		}
		
		
		
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
			}
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click = {
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>


#Nuget installation
$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
$nugetInstallPath = "$env:ProgramFiles\NuGet"
if (-not (Test-Path -Path $nugetInstallPath))
{
	New-Item -ItemType Directory -Path $nugetInstallPath -Force
}
$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
if (Test-Path -Path $nugetExePath)
{
	Write-Host "NuGet has been installed successfully at $nugetExePath"
}
else
{
	Write-Host "NuGet installation failed"
}
$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
if ($path -notlike "*$nugetInstallPath*")
{
	[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
	Write-Host "NuGet has been added to the system PATH"
}
else
{
	Write-Host "NuGet is already in the system PATH"
}
& $nugetExePath | Select-String "NuGet Version"


Get-PackageProvider -Name Nuget -Force

#Installation Powershell Modules
Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		Write-Host "IntuneWin32App 1.4.4 already installed"
	}
	else
	{
		Write-Host "Required Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Authentication 2.18.0 already installed"
	}
	else
	{
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}

Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Applications 2.18.0 already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		Write-Host "CredentialManager 2.0.0 Powershell module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
	
}
Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 18) -and ($moduleVersion.Version.Build -eq 0))
	{
		Write-Host "Microsoft.Graph.Identity.SignIns 2.18.0 Powershell Module already installed"
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	}
}
else
{
	Write-Host "Required Module and Version not found.. Now installing"
	Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.18.0 -Force -SkipPublisherCheck -Confirm:$False
	
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click = {
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click = {
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click = {
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click = {
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$download_winget_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click = {
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click = {
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click = {
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click = {
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click = {
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
		
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		try
		{
			$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUbinstall.ps1 NIET created `r`n")
		}
	}
}

$exe_radiobutton3_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $powershell_package_name_textbox1.text
	$exeversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if ([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$exepnaam\$exeversie\output\config.csv file there", 'Upload Now?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
		
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$button1_Click = {
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
		
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click = {
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$addTenantToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked = [System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click = {
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click = {
	#TODO: Place custom script here
	
	$tenantName = $config_tenant_name_textbox3.Text
	$appRegName = $config_tenant_appRegName_textbox3.Text
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant with Global Admin rights. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		if ($config_add_Tenant_radiobutton1.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppReg.exe" -appRegName $appRegName -customername $tenantName
		}
		if ($config_add_Tenant_radiobutton2.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe" -appRegName $appRegName -customername $tenantName
		}
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		refreshTenantsUpload
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click = {
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click = {
	
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click = {
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click = {
	#TODO: Place custom script here
	Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click = {
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
	
}

$MSIX_CreateScripts_button2_Click = {
	
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	#$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
	
	
}

$msix_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_test_uninstall_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$MSIX_create_uninstall_Script_button2_Click = {
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName)
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click = {
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	$msix_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$MSIX_UploadLogo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$msixpnaam\$msixversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$powershell_open_install_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellpnaam = $powershellpnaam -replace (" ", "")
	$powershell_packagename_textbox.text = $powershellpnaam
	$powershellversie = $powershell_packageversion_textbox.Text
	
	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click = {
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		if (($powershell_radiobutton2.Checked -eq $false) -and ($powershell_radiobutton1.Checked -eq $false))
		{
			[void][System.Windows.Forms.MessageBox]::Show('Select user or system context first', 'Please select user or system context first')
		}
		else
		{
			
			$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
			
			$powershelll_user_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1  }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
			$powershelll_user_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1  }
else { remove-item $regkeyApp; exit 0 }
'@
			
if ($powershell_radiobutton2.Checked -eq $true)
	{
	$powershelll_installFile = $powershelll_user_installFile
	$powershell_uninstallFile = $powershelll_user_uninstallFile
	}
	if ($powershell_radiobutton1.Checked -eq $true) {
	$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
			$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
				
			}
			
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
			$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
			$powershellpnaam = $powershell_packagename_textbox.text
			$powershellversie = $powershell_packageversion_textbox.Text
			$fid = $config_packagefolder; $outputDirectory = $fid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_install_org_path -Confirm:$false
			$powershellInputInstall = Get-Content -Path $powershell_install_org_path
			#Write-Host $powershellInputInstall
		
			$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
			$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
			$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			foreach ($line in $powershelll_installFile)
			{
				if ($line -like "#PowershellInstallStart*")
				{
					
					foreach ($inputLine in $powershellInputInstall)
					{
						
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
				
				
			}
				
			
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			
			
			
			
			
			
			[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
			$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
			$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			foreach ($line in $powershell_uninstallFile)
			{
				if ($line -like '#PowershellUninstallStart*')
				{
					
					foreach ($inputLine in $powershellInputUNInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
				
				
			}
			$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
			$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
			$Powershell_testUnInstall_button2.Enabled = $true
			$Powershell_testUnInstall_button2.Visible = $true
			$Powershell_testInstall_button2.Enabled = $true
			$Powershell_testInstall_button2.Visible = $true
			$Powershell_CreateIntuneWIn_button2.Enabled = $true
			$Powershell_CreateIntuneWIn_button2.Visible = $true
			
		}
	}

}

$powershell_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test install?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_testUnInstall_button2_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstall?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.text
		$powershellversie = $powershell_packageversion_textbox.Text
		powershell_ise -file "$config_packagefolder\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$Powershell_CreateIntuneWIn_button2_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$msipnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$powershell_output_textbox5.AppendText("un-install command is: `r`n")
	$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Versie' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
		[string]$context
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$context = 'user'
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$context = 'system'
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			context		  = $context
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("When needed upload Logo to upload *.png file. `r`n")
	$powershell_output_textbox5.AppendText("Then use this config.csv in the upload tab to upload package to Intune. `r`n")
}

$Powershell_upload_logo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$powershellpnaam\$powershellversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
	$powershell_output_textbox5.AppendText("`r`n")
	$powershell_output_textbox5.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$updatepackage_msi_open_config_button1_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click = {
	#TODO: Place custom script here
	
}

$labelAppName_Click = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged = {
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click = {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$updatepackage_msi_appname_new_textbox3.text = $powershellpnaam
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}



$exe_open_Azure_OpenAI_Example_button1_Click = {
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click = {
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
		
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key		       = $config_openAI_textbox6.Text
			endpointURL    = $config_openAI_textbox7.Text
			deploymentName = $config_openAI_textbox8.Text
			
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}


$config_openAI_help_Click = {
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"
}




$config_openAI_textbox8_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox6_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_radiobutton2_CheckedChanged={
	#TODO: Place custom script here
	
}

$updatePackageIntunewinToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$updatepackage_exe_open_config_button1_Click={
	#TODO: Place custom script here
	$update_exe_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$update_exe_appname_old_textbox5.Text = $ConfigCSVImport.DisplayName
	$update_exe_new_appname_textbox7.Text = $ConfigCSVImport.DisplayName
	$update_exe_appversion_old_textbox4.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$update_exe_customer_old_textbox3.Text = $updatepackage_customername
	$updatepackage_EXE_panel6.Enabled = $true
	$updatepackage_EXE_panel6.Visible = $true
	$update_exe_panel4.Visible = $true
	$update_exe_panel4.Enabled = $true
}

$update_exe_buttonStep2CloneToNewDirec_Click={
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($update_exe_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($update_exe_new_appversion_textbox6.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $update_exe_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $update_exe_new_appname_textbox7.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$update_exe_new_appname_textbox7.text = $powershellpnaam
		$powershellversie = $update_exe_new_appversion_textbox6.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_exe_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_exe_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $update_exe_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_exe_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appName =*') -or ($lni -like '$version  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$appName =*') -or ($lni -like 'Versie =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("Replace EXE file for newer version with a. EXE file with the same name or b. change the Install parameters below")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		<#
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		#>
		$update_exe_panel6.Enabled = $true
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		foreach ($lni2 in $installparameters)
		{
			if ($lni2 -like '$exeParameters =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exeparameters2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exeparameters2 = $null
				}
				$exeparameters2 = $exeparameters2 -replace "^ ", ""
				$exeparameters2 = $exeparameters2.split("#")[0]
				$update_exe_installPar_textbox3.Text = $exeparameters2
			}
			if ($lni2 -like '$exeFile =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exefilename2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exefilename2 = $null
				}
				$exefilename2 = $exefilename2 -replace "^ ", ""
				
				$update_exe_Exefilename_textbox3.Text = $exefilename2
			}
			
		}

	
		$IsThisLineThereInUninstall = $old_uninstallps1 | ForEach-Object {
			if ($_ -match 'Please see u\.cmd for MSI parameters used by this script')
			{
				$_.Trim() 
			}
		} | Where-Object { $_ }
		if ($IsThisLineThereInUninstall)
		{
			Write-Host "De regel is aanwezig: $IsThisLineThereInUninstall"
			$update_exe_uninstall_panel6.Enabled = $false
			$update_exe_uninstall_panel6.Visible = $false
			$update_Exe_Uninstall_MSI_panel6.Enabled = $true
			$update_Exe_Uninstall_MSI_panel6.Visible = $true
			$update_exe_msi_uninstallcommandsOld = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\u.cmd"
			$udpdate_exe_msi_uninstall_textbox4.Text = $update_exe_msi_uninstallcommandsOld
			[void][System.Windows.Forms.MessageBox]::Show('See Find Uninstall String in the tools menu to search for new uninstall productcode and change the uninstall parameters after testing installation', 'Change uninstall string')
			
		}
		else
		{
			$oldInstallExeFilename = $old_installps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeFilename = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeParameters = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeParameters\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			#Write-Host "Old Install EXE Filename: $oldInstallExeFilename"
			#Write-Host "Old Uninstall EXE Filename: $oldUnInstallExeFilename"
			if ($oldInstallExeFilename -like $oldUnInstallExeFilename)
			{
				#Write-Host "Same EXE as install: $oldUnInstallExeFilename)"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
			Else
			{
				#Write-Host "Uninstall EXE path is $oldUnInstallExeFilename"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
		}
		
		
		
	}
}

$update_exe_buttonStep3OpenSourceDirec_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	$update_exe_buttonStep4SaveInstallPara.Enabled = $true
}

$update_exe_buttonStep4SaveInstallPara_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$installparameters = Get-Content "$newpackage_sourcepath\install.ps1"
	Remove-Item "$newpackage_sourcepath\install.ps1"
	foreach ($lni2 in $installparameters)
	{
		if (($lni2 -like '$exeParameters =*') -or ($lni2 -like '$exeFile =*'))
		{
			
			
			if ($lni2 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_installPar_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
			if ($lni2 -like '$exeFile =*')
			{
				
				'$exeFile = ' + $update_exe_Exefilename_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
		}
		else
		{
			$lni2 | Out-File "$newpackage_sourcepath\install.ps1" -Append
		}
		
	}
	$update_exe_buttonStep5TestAndEditInst.Enabled = $true
}

$update_exe_buttonStep5TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\install.ps1"
	
}

$buttonStep7TestAndEditUnin_Click={
	#TODO: Place custom script here
	
}

$update_exe_uninstall_msi_save_button3_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$udpdate_exe_msi_uninstall_textbox4.Text | Out-File "$newpackage_sourcepath\u.cmd" -Force
	$update_exe_uninstall_MSI_Test_button2.Enabled = $true
}

$update_exe_uninstall_MSI_Test_button2_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$buttonStep6SaveUninstallPa_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$uninstall_exe_uninstall = Get-Content "$newpackage_sourcepath\uninstall.ps1"
	Remove-Item "$newpackage_sourcepath\uninstall.ps1" -Confirm:$false -Force
	foreach ($lni5 in $uninstall_exe_uninstall)
	{
		if (($lni5 -like '$exeFile =*') -or ($lni5 -like '$exeParameters =*'))
		{
			if ($lni5 -like '$exeFile =*')
			{
				'$exeFile = ' + $update_exe_filetpathUninstall_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
			if ($lni5 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_uninstall_parameters_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
		}
		else
		{
			$lni5 | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			
		}
		
	}
	$update_exe_testuninstall_exe_buttonStep7TestAndEditInst.Enabled = $true
	
}

$update_exe_testuninstall_exe_buttonStep7TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$update_exe_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $update_exe_new_appname_textbox7.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_exe_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_exe_output_textbox4.AppendText("`r`n")
	
	$updatepackage_exe_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
}


$tools_choco_search_button2_Click={
	#TODO: Place custom script here
	
	
	function chocoSearch
	{
		param (
			[Parameter(Mandatory = $true)]
			[string]$name,
			[bool]$approvedOnly = $false
		)
		
		$chocoSearch = choco find $name --order-by-popularity
		if ($chocoSearch.Count -gt 2)
		{
			$chocoSearch = $chocoSearch[1 .. ($chocoSearch.Count - 2)]
		}
		
		$results = @()
		
		foreach ($ch in $chocoSearch)
		{
			$splitLine = $ch.Split(" ", 3, [System.StringSplitOptions]::RemoveEmptyEntries)
			if ($splitLine.Count -lt 2)
			{
				continue
			}
			
			$currentName = $splitLine[0]
			$currentVersion = $splitLine[1]
			$remaining = ""
			if ($splitLine.Count -eq 3)
			{
				$remaining = $splitLine[2]
			}
			if ($ch -match 'found|know|Learn')
			{
				continue
			}
			$isApproved = ($remaining -match '\[Approved\]')
			if ($approvedOnly -and -not $isApproved)
			{
				continue
			}
			$obj = [pscustomobject]@{
				Name	 = $currentName
				Version  = $currentVersion
				Approved = $isApproved
			}
			
			$results += $obj
		}
		
		return $results
	}
	$sChoco = $tools_choco_search_textbox3.Text
	
	
	if ($tools_choco_checkbox1.Checked -eq $true)
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $true
	}
	else
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $false
	}
	try
	{
		New-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script
	}
	

	$tools_choco_treeview2.BeginUpdate()
	$tools_choco_treeview2.Refresh()
	$tools_choco_treeview2.Nodes.Clear()
	#$tools_choco_treeview2.CheckBoxes = $true
	$Root = $tools_choco_treeview2.Nodes.Add("Choco Packages")
	foreach ($p in $chocoOutput)
	{
		#$upload_treeview2.Nodes.Add($tenantCSV.customername)
		$node = $Root.Nodes.Add($p.Name)
		
		$node.ContextMenuStrip = $tools_choco_contextmenustrip1
		#$node.Tag = $tenantCSV.target
		$node.Name = $p.Name
		
		
	}
	$Root.Expand()
	$tools_choco_treeview2.EndUpdate()
}

$config_tenants_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}



$tools_choco_contextmenustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$choco_toolstripmenuitem1_Click= {
	#TODO: Place custom script here
	

}
$tools_choco_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$chocoAll = Get-Variable -Name 'chocoOutput2' -Scope Script -ValueOnly
	$tools_choco_details_richtextbox1.text = ""
	
	foreach ($ch1 in $chocoAll)
	{
		if ($ch1.Name -eq $tools_choco_treeview2.SelectedNode.Name)
		{
			$tools_choco_panel6.Enabled = $true
			$tools_choco_selected_label6.Enabled = $true
			$tools_choco_selected_label6.Visible = $true
			$tools_choco_selected_label6.Text = $ch1.Name
			$chocoDetails = choco find $ch1.Name --exact --detail
			foreach ($ch2 in $chocoDetails)
			{
				$tools_choco_details_richtextbox1.AppendText("`r`n")
				$tools_choco_details_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}



$tools_choco_createdir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $tools_choco_displayname_textbox3.text
	$exeversie = $tools_choco_appversion_textbox3.text
	$exepnaam = $exepnaam -replace (" ", "")
	$tools_choco_displayname_textbox3.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$tools_choco_output_textbox3.Text = "`nNew package directory created: `r`n"
			$tools_choco_output_textbox3.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$tools_choco_output_textbox3.AppendText("`r`n")
			$tools_choco_panel7.Enabled = $true
			$tools_choco_open_PackageDir_button2.Enabled = $true
		}
	}
}
$tools_choco_displayname_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_appversion_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_createscriots_button2_Click={
	#TODO: Place custom script here
	$choco_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:19
	 Created by:   	Rink Turksma
	 Organization: 	https://githhub.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"
$paramsChoco = "!!paramsChocho!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
if (!(test-path -Path "$env:programdata\chocolatey"))
	{
		write-host "Installing Chocolatey"
		[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
	}


write-host "Now installing: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green
try
{
	write-host "Choco installation started" -ForegroundColor Green
	if ($paramsChoco -eq 'false')
	{
		choco install $chocoName --exact --yes --force
	}
	else
	{
		choco install $chocoName --exact --params $paramsChoco --yes --force
	}
	write-host "Installation success" -ForegroundColor Green
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	write-host "Now creating weekly scheduled task to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Monday -At 10:00
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}

if ($startupUpdateTask -eq 'true')
{
	write-host "Now creating scheduled task at startup to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -AtStartup
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}


try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	$choco_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:25
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
write-host "Now uninstalling: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green




try
{
	write-host "Choco uninstallation started" -ForegroundColor Green
	choco uninstall $chocoName --exact --yes --force
	write-host "UnInstallation success" -ForegroundColor Green
}
catch
{
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}
if ($startupUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
	
}

### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000)
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$RegisterDetectionroot = "Intune_" + $config_customername
	$appVersion = $tools_choco_appversion_textbox3.text
	$appName = '"' + $tools_choco_displayname_textbox3.text + '"'
	$appName2 = $tools_choco_displayname_textbox3.text
	$chocoName = $tools_choco_selected_label6.Text
	
	$choco_installFile  = $choco_installFile.Replace('"!!AppName!!"', $appName)
	$choco_installFile  = $choco_installFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_installFile  = $choco_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_installFile  = $choco_installFile.Replace('!!version!!', $appVersion)
	$choco_installFile = $choco_installFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true' 
	$choco_installFile = $choco_installFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true) { $paramschoco = $tools_choco_parammstextbox3.Text; $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', $paramschoco) }
	else { $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', 'false') }
	try
	{
		$choco_installFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$appName2\$appVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	$choco_uninstallFile = $choco_uninstallFile.Replace('"!!AppName!!"', $appName)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!version!!', $appVersion)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true'
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	try
	{
		$choco_uninstallFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\uninstall.ps1" -Force -ErrorAction Stop
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
		$tools_choco_panel11.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 NOT created `r`n")
	}
}

$tools_choco_open_PackageDir_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$AppVersion = $tools_choco_appversion_textbox3.text
	Invoke-Item "$config_packagefolder\$appName\$appVersion\"
}

$tools_choco_testinstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$appName = $tools_choco_displayname_textbox3.text
		$appVersion = $tools_choco_appversion_textbox3.text
		powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$tools_choco_testUNinstall_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$config_download_Choco_MSIX_bundle_Click={
	#TODO: Place custom script here
	
	$config_install_required_chocolatey = @'
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$picturebox1_Click={
	#TODO: Place custom script here
	
}

$tools_choco_AddParams_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true)
	{
		$tools_choco_parammstextbox3.Enabled = $true
		$tools_choco_parammstextbox3.Visible = $true
	}
	else
	{
		$tools_choco_parammstextbox3.Enabled = $false
		$tools_choco_parammstextbox3.Visible = $false
	}
}

$tools_choco_create_intunewin_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$appName\$appVersion\source\" -s "$config_packagefolder\$appName\$appVersion\source\install.ps1" -o "$config_packagefolder\$appName\$appVersion\output\" -q
	Rename-Item -Path "$config_packagefolder\$appName\$appVersion\output\install.intunewin" -NewName "$config_packagefolder\$appName\$appVersion\output\$appName.intunewin"
	$tools_choco_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\$appName.intunewin")
	$tools_choco_output_textbox3.AppendText("`r`n")
	
	$tools_choco_output_textbox3.AppendText("Install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("un-install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$appName\"
	$regkeyApp
	$tools_choco_output_textbox3.AppendText("$regkeyApp `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: $appVersion `r`n")
	$tools_choco_output_textbox3.AppendText("Please reopen tool to make another Chocolatey package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$appName.intunewin"
			DisplayName   = $appName
			Publisher	  = $config_customername
			AppVersion    = $appVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$appName\$appVersion\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$appName\$appVersion\output\"
	$tools_choco_output_textbox3.AppendText("Config.csv written to naar: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\config.csv")
	$tools_choco_output_textbox3.AppendText("  `r`n")
	$tools_choco_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$tools_choco_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$tools_choco__upload_logo_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$appName\$appVersion\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$tools_choco_output_textbox3.AppendText("`r`n")
	$tools_choco_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}
]]></Code>
  <TV>0</TV>
  <Mode>1</Mode>
  <Assemblies>
    <Assembly>Renci.SshNet, Version=2016.0.0.0, Culture=neutral, PublicKeyToken=1cee9f8bde3db106|C:\Users\rink\Desktop\ex-desktop\Renci.SshNet.dll</Assembly>
  </Assemblies>
</File>